//// Code Generator
////
//// Transforms parsed template ASTs into executable Gleam code.
//// Generates functions that build HTML strings using the
//// runtime helpers for escaping, conditionals, and loops.
////

import gleam/dict.{type Dict}
import gleam/list
import gleam/option.{type Option, None, Some}
import gleam/set.{type Set}
import gleam/string
import glimr/loom/gleam_parser.{type ParsedViewFile}
import glimr/loom/lexer
import glimr/loom/parser.{type Node, type Template}

// ------------------------------------------------------------- Public Types

/// Maps component names to their expected data fields. Used
/// to generate default values for missing props when
/// rendering components.
///
pub type ComponentDataMap =
  Dict(String, List(#(String, String)))

/// Information about a component's slot usage. Tracks whether
/// the component uses a default slot and what named slots
/// it accepts.
///
pub type ComponentSlotInfo {
  ComponentSlotInfo(has_default_slot: Bool, named_slots: List(String))
}

/// Maps component names to their slot information. Used when
/// generating component calls to determine which slot
/// arguments to include.
///
pub type ComponentSlotMap =
  Dict(String, ComponentSlotInfo)

/// The result of code generation. Contains the module name
/// and the complete generated Gleam source code ready to
/// be written to a file.
///
pub type GeneratedCode {
  GeneratedCode(module_name: String, code: String)
}

// ------------------------------------------------------------- Public Functions

/// Generates Gleam code from a parsed template. Takes the AST,
/// module metadata, and type information to produce complete
/// source code with imports and the html function.
///
pub fn generate(
  template: Template,
  module_name: String,
  is_component: Bool,
  view_file: Option(ParsedViewFile),
  component_data: ComponentDataMap,
  component_slots: ComponentSlotMap,
) -> GeneratedCode {
  let code =
    generate_module(
      template,
      module_name,
      is_component,
      view_file,
      component_data,
      component_slots,
    )
  GeneratedCode(module_name: module_name, code: code)
}

/// Extracts all named slot references from a template. Walks
/// the AST to find @slot("name") directives and returns a
/// deduplicated list of slot names.
///
pub fn extract_named_slots(template: Template) -> List(String) {
  collect_named_slots(template.nodes, set.new())
  |> set.to_list
}

/// Extracts complete slot information from a component template.
/// Returns whether it has a default slot and the list of
/// named slots it accepts.
///
pub fn extract_slot_info(template: Template) -> ComponentSlotInfo {
  ComponentSlotInfo(
    has_default_slot: has_default_slot(template.nodes),
    named_slots: collect_named_slots(template.nodes, set.new()) |> set.to_list,
  )
}

// ------------------------------------------------------------- Private Functions

/// Generates the complete module source code. Combines the
/// header comment, imports, and html function into a single
/// string ready for writing.
///
fn generate_module(
  template: Template,
  _module_name: String,
  is_component: Bool,
  view_file: Option(ParsedViewFile),
  component_data: ComponentDataMap,
  component_slots: ComponentSlotMap,
) -> String {
  let header =
    "// This file was generated by Glimr ✨
// https://github.com/glimr-org/glimr?tab=readme-ov-file#loom
//
// Do not edit this file directly. Instead, edit the corresponding
// .loom.html template file and run `./glimr loom:compile`.
"
  let imports = generate_imports(template, view_file)
  let html_fn =
    generate_html_function(
      template,
      is_component,
      view_file,
      component_data,
      component_slots,
    )

  string.join([header, imports, "", html_fn], "\n")
}

/// Generates import statements for the module. Includes the
/// runtime, user imports, and imports for all referenced components.
///
fn generate_imports(
  template: Template,
  view_file: Option(ParsedViewFile),
) -> String {
  let base_imports = ["import glimr/loom/runtime"]

  // Copy user imports for custom types (filter out glimr/bootstrap imports)
  let user_imports = case view_file {
    Some(vf) ->
      vf.imports
      |> list.filter(fn(imp) { !string.contains(imp, "compiled/") })
    None -> []
  }

  let component_names = collect_component_names(template.nodes, set.new())
  let component_imports =
    component_names
    |> set.to_list
    |> list.sort(string.compare)
    |> list.map(fn(name) {
      let module_path =
        "compiled/loom/components/" <> string.replace(name, ":", "/")
      let alias = component_module_alias(name)
      "import " <> module_path <> " as " <> alias
    })

  string.join(
    list.flatten([base_imports, user_imports, component_imports]),
    "\n",
  )
}

/// Recursively collects all component names from the AST.
/// Traverses into nested structures to find every component
/// reference for import generation.
///
fn collect_component_names(nodes: List(Node), acc: Set(String)) -> Set(String) {
  list.fold(nodes, acc, fn(acc, node) {
    case node {
      parser.ComponentNode(name, _, children) -> {
        let acc = set.insert(acc, name)
        collect_component_names(children, acc)
      }
      parser.IfNode(branches) ->
        list.fold(branches, acc, fn(acc, branch) {
          collect_component_names(branch.1, acc)
        })
      parser.EachNode(_, _, _, body) -> collect_component_names(body, acc)
      parser.SlotDefNode(_, children) -> collect_component_names(children, acc)
      parser.ElementNode(_, _, children) ->
        collect_component_names(children, acc)
      _ -> acc
    }
  })
}

/// Recursively collects all named slot references from nodes.
/// Finds <slot name="..."> elements throughout the template
/// including inside nested structures.
///
fn collect_named_slots(nodes: List(Node), acc: Set(String)) -> Set(String) {
  list.fold(nodes, acc, fn(acc, node) {
    case node {
      parser.SlotNode(Some(name), fallback) -> {
        let acc = set.insert(acc, name)
        collect_named_slots(fallback, acc)
      }
      parser.SlotNode(None, fallback) -> collect_named_slots(fallback, acc)
      parser.IfNode(branches) ->
        list.fold(branches, acc, fn(acc, branch) {
          collect_named_slots(branch.1, acc)
        })
      parser.EachNode(_, _, _, body) -> collect_named_slots(body, acc)
      parser.ComponentNode(_, _, children) -> collect_named_slots(children, acc)
      parser.SlotDefNode(_, children) -> collect_named_slots(children, acc)
      parser.ElementNode(_, _, children) -> collect_named_slots(children, acc)
      _ -> acc
    }
  })
}

/// Generates the main html function for the template. Builds
/// the function signature with data and slot parameters, then
/// generates the body from the template nodes.
///
fn generate_html_function(
  template: Template,
  is_component: Bool,
  view_file: Option(ParsedViewFile),
  component_data: ComponentDataMap,
  component_slots: ComponentSlotMap,
) -> String {
  // For components, inject @attributes into first element if not present
  let nodes = case is_component {
    True ->
      case has_attributes_node(template.nodes) {
        True -> template.nodes
        False -> inject_attributes_into_first_element(template.nodes)
      }
    False -> template.nodes
  }

  // Build function parameters
  let params = generate_function_params(template, is_component, view_file)

  let body = generate_nodes_code(nodes, 1, component_data, component_slots)
  "pub fn html(" <> params <> ") -> String {\n" <> "  \"\"\n" <> body <> "}\n"
}

/// Generates the function parameter list. Includes data fields
/// from the view file, slot parameters, and attributes for
/// components.
///
fn generate_function_params(
  template: Template,
  is_component: Bool,
  view_file: Option(ParsedViewFile),
) -> String {
  // Data fields from parsed view file
  let data_params = case view_file {
    Some(vf) ->
      vf.fields
      |> list.map(fn(field) {
        let #(name, type_str) = field
        name <> " " <> name <> ": " <> type_str
      })
    None -> []
  }

  // Slot parameters from template
  let slot_params = case has_default_slot(template.nodes) {
    True -> ["slot slot: String"]
    False -> []
  }

  let named_slots =
    collect_named_slots(template.nodes, set.new()) |> set.to_list
  let named_slot_params =
    named_slots
    |> list.sort(string.compare)
    |> list.map(fn(name) {
      "slot_"
      <> to_field_name(name)
      <> " slot_"
      <> to_field_name(name)
      <> ": String"
    })

  // Attributes parameter for components
  let attr_params = case is_component {
    True -> ["attributes attributes: List(runtime.Attribute)"]
    False -> []
  }

  list.flatten([data_params, slot_params, named_slot_params, attr_params])
  |> string.join(", ")
}

/// Checks if the template uses a default slot. Recursively
/// searches for <slot> elements without a name attribute
/// throughout the AST.
///
fn has_default_slot(nodes: List(Node)) -> Bool {
  list.any(nodes, fn(node) {
    case node {
      parser.SlotNode(None, _) -> True
      parser.SlotNode(Some(_), fallback) -> has_default_slot(fallback)
      parser.IfNode(branches) ->
        list.any(branches, fn(branch) { has_default_slot(branch.1) })
      parser.EachNode(_, _, _, body) -> has_default_slot(body)
      parser.ComponentNode(_, _, children) -> has_default_slot(children)
      parser.SlotDefNode(_, children) -> has_default_slot(children)
      parser.ElementNode(_, _, children) -> has_default_slot(children)
      _ -> False
    }
  })
}

/// Separates slot definitions from regular content nodes.
/// Returns default content nodes and a list of named slot
/// definitions for separate rendering.
///
fn separate_slot_defs(
  nodes: List(Node),
) -> #(List(Node), List(#(Option(String), List(Node)))) {
  list.fold(nodes, #([], []), fn(acc, node) {
    let #(default_nodes, slot_defs) = acc
    case node {
      parser.SlotDefNode(name, children) -> #(
        default_nodes,
        list.append(slot_defs, [#(name, children)]),
      )
      _ -> #(list.append(default_nodes, [node]), slot_defs)
    }
  })
}

/// Transforms slot references in conditions.
/// - `slot` alone → `slot != ""`
/// - `slot.header` → `slot_header != ""`
/// Other expressions pass through unchanged.
///
fn transform_slot_condition(condition: String) -> String {
  let trimmed = string.trim(condition)
  case trimmed {
    // Exact match for "slot" - transform to emptiness check
    "slot" -> "slot != \"\""
    // Check for slot.X pattern
    _ -> {
      case string.starts_with(trimmed, "slot.") {
        True -> {
          // Transform slot.header to slot_header != ""
          let name = string.drop_start(trimmed, 5)
          "slot_" <> to_field_name(name) <> " != \"\""
        }
        False -> condition
      }
    }
  }
}

/// Generates code for a list of nodes. Maps over each node
/// and concatenates the generated code with appropriate
/// indentation.
///
fn generate_nodes_code(
  nodes: List(Node),
  indent: Int,
  component_data: ComponentDataMap,
  component_slots: ComponentSlotMap,
) -> String {
  nodes
  |> list.map(fn(node) {
    generate_node_code(node, indent, component_data, component_slots)
  })
  |> string.join("")
}

/// Generates code for a single AST node. Handles all node
/// types: text, variables, slots, conditionals, loops,
/// and component invocations.
///
fn generate_node_code(
  node: Node,
  indent: Int,
  component_data: ComponentDataMap,
  component_slots: ComponentSlotMap,
) -> String {
  let pad = string.repeat("  ", indent)

  case node {
    parser.TextNode(text) -> {
      let escaped = escape_gleam_string(text)
      pad <> "<> \"" <> escaped <> "\"\n"
    }

    parser.VariableNode(expr) -> {
      // Expression is passed through directly (e.g., "title", "user.name")
      pad <> "<> runtime.escape(" <> expr <> ")\n"
    }

    parser.RawVariableNode(expr) -> {
      // Expression is passed through directly
      pad <> "<> " <> expr <> "\n"
    }

    parser.SlotNode(None, []) -> {
      // <slot /> - no fallback, just output slot
      pad <> "<> slot\n"
    }

    parser.SlotNode(None, fallback) -> {
      // <slot>fallback</slot> - output fallback if slot is empty
      let fallback_code =
        generate_nodes_code(
          fallback,
          indent + 1,
          component_data,
          component_slots,
        )
      pad
      <> "|> runtime.append_if(slot == \"\", fn(acc) {\n"
      <> pad
      <> "  acc\n"
      <> fallback_code
      <> pad
      <> "})\n"
      <> pad
      <> "|> runtime.append_if(slot != \"\", fn(acc) { acc <> slot })\n"
    }

    parser.SlotNode(Some(name), []) -> {
      // <slot name="x" /> - no fallback
      pad <> "<> slot_" <> to_field_name(name) <> "\n"
    }

    parser.SlotNode(Some(name), fallback) -> {
      // <slot name="x">fallback</slot>
      let slot_var = "slot_" <> to_field_name(name)
      let fallback_code =
        generate_nodes_code(
          fallback,
          indent + 1,
          component_data,
          component_slots,
        )
      pad
      <> "|> runtime.append_if("
      <> slot_var
      <> " == \"\", fn(acc) {\n"
      <> pad
      <> "  acc\n"
      <> fallback_code
      <> pad
      <> "})\n"
      <> pad
      <> "|> runtime.append_if("
      <> slot_var
      <> " != \"\", fn(acc) { acc <> "
      <> slot_var
      <> " })\n"
    }

    parser.SlotDefNode(_, _) -> {
      // SlotDefNodes are handled separately (when using components)
      ""
    }

    parser.IfNode(branches) -> {
      // Generate case expression for if/elseif/else
      let branches_code =
        list.map(branches, fn(branch) {
          let #(condition, body) = branch
          let body_code =
            generate_nodes_code(
              body,
              indent + 4,
              component_data,
              component_slots,
            )
          case condition {
            Some(cond) -> {
              // Transform slot references: slot -> slot != "", slot.x -> slot_x != ""
              let transformed_cond = transform_slot_condition(cond)
              pad
              <> "    _ if "
              <> transformed_cond
              <> " -> {\n"
              <> pad
              <> "      \"\"\n"
              <> body_code
              <> pad
              <> "    }\n"
            }
            None ->
              pad
              <> "    _ -> {\n"
              <> pad
              <> "      \"\"\n"
              <> body_code
              <> pad
              <> "    }\n"
          }
        })
        |> string.join("")

      // Check if there's an else branch (None condition)
      let has_else =
        list.any(branches, fn(branch) {
          case branch.0 {
            None -> True
            Some(_) -> False
          }
        })

      // Add default empty branch if no else
      let final_branches = case has_else {
        True -> branches_code
        False -> branches_code <> pad <> "    _ -> \"\"\n"
      }

      pad <> "<> case Nil {\n" <> final_branches <> pad <> "  }\n"
    }

    parser.EachNode(collection, items, loop_var, body) -> {
      // Collection is passed through directly (e.g., "items")
      let body_code =
        generate_nodes_code(body, indent + 2, component_data, component_slots)
      let items_pattern = format_each_items_pattern(items)
      case loop_var {
        None ->
          pad
          <> "|> runtime.append_each("
          <> collection
          <> ", fn(acc, "
          <> items_pattern
          <> ") {\n"
          <> pad
          <> "  acc\n"
          <> body_code
          <> pad
          <> "})\n"
        Some(loop_name) ->
          pad
          <> "|> runtime.append_each_with_loop("
          <> collection
          <> ", fn(acc, "
          <> items_pattern
          <> ", "
          <> loop_name
          <> ") {\n"
          <> pad
          <> "  acc\n"
          <> body_code
          <> pad
          <> "})\n"
      }
    }

    parser.ComponentNode(name, attributes, children) -> {
      let module_alias = component_module_alias(name)
      let #(default_children, named_slots) = separate_slot_defs(children)
      let #(props_code, extra_attrs_code) =
        generate_component_attrs(name, attributes, indent + 2, component_data)
      let named_slots_code =
        generate_component_named_slots(
          name,
          named_slots,
          indent + 2,
          component_data,
          component_slots,
        )

      // Check if the component has a default slot
      let slot_info = dict.get(component_slots, name)
      let component_has_slot = case slot_info {
        Ok(info) -> info.has_default_slot
        Error(_) -> True
        // Default to True if unknown (safe fallback)
      }

      // Only include slot argument if component has @slot
      let slot_code = case component_has_slot {
        True -> {
          let default_slot_code =
            generate_nodes_code(
              default_children,
              indent + 2,
              component_data,
              component_slots,
            )
          pad
          <> "    slot: {\n"
          <> pad
          <> "      \"\"\n"
          <> default_slot_code
          <> pad
          <> "    },\n"
        }
        False -> ""
      }

      pad
      <> "<> "
      <> module_alias
      <> ".html(\n"
      <> props_code
      <> named_slots_code
      <> slot_code
      <> pad
      <> "    attributes: "
      <> extra_attrs_code
      <> ",\n"
      <> pad
      <> "  )\n"
    }

    parser.AttributesNode(base_attrs) -> {
      case base_attrs {
        [] -> pad <> "<> \" \" <> runtime.render_attributes(attributes)\n"
        _ -> {
          let base_attrs_code = generate_base_attrs_code(base_attrs)
          pad
          <> "<> \" \" <> runtime.render_attributes(runtime.merge_attributes("
          <> base_attrs_code
          <> ", attributes))\n"
        }
      }
    }

    parser.ElementNode(tag, attributes, children) -> {
      let attrs_code = generate_element_attrs_code(attributes)
      let children_code =
        generate_nodes_code(children, indent, component_data, component_slots)

      // Self-closing tags
      case is_void_element(tag) {
        True ->
          pad
          <> "<> \"<"
          <> tag
          <> "\"\n"
          <> attrs_code
          <> pad
          <> "<> \" />\"\n"
        False ->
          pad
          <> "<> \"<"
          <> tag
          <> "\"\n"
          <> attrs_code
          <> pad
          <> "<> \">\"\n"
          <> children_code
          <> pad
          <> "<> \"</"
          <> tag
          <> ">\"\n"
      }
    }
  }
}

/// Generates component attribute code. Separates props from
/// HTML attributes, generates defaults for missing props,
/// and builds the attributes list for pass-through.
///
fn generate_component_attrs(
  component_name: String,
  attributes: List(lexer.ComponentAttr),
  indent: Int,
  component_data: ComponentDataMap,
) -> #(String, String) {
  let pad = string.repeat("  ", indent)

  // Get the expected props for this component
  let expected_prop_names = case dict.get(component_data, component_name) {
    Error(_) -> []
    Ok(props) -> list.map(props, fn(p) { p.0 })
  }

  // Get explicitly provided props from expression attributes AND boolean attributes that match prop names
  let explicit_props =
    attributes
    |> list.filter_map(fn(attr) {
      case attr {
        lexer.ExprAttr(name, _) -> {
          // Expression attribute is a prop only if it matches an expected prop name
          let field_name = to_field_name(name)
          case list.contains(expected_prop_names, field_name) {
            True -> Ok(field_name)
            False -> Error(Nil)
          }
        }
        lexer.BoolAttr(name) -> {
          // Boolean attribute is a prop if it matches an expected prop name
          let field_name = to_field_name(name)
          case list.contains(expected_prop_names, field_name) {
            True -> Ok(field_name)
            False -> Error(Nil)
          }
        }
        _ -> Error(Nil)
      }
    })

  // Generate prop field assignments for expression bindings (:prop="expr") that match prop names
  // AND boolean attributes that match prop names (set to True)
  let explicit_props_code =
    attributes
    |> list.filter_map(fn(attr) {
      case attr {
        lexer.ExprAttr(name, value) -> {
          // Only generate prop assignment if name matches an expected prop
          let field_name = to_field_name(name)
          case list.contains(expected_prop_names, field_name) {
            True -> Ok(pad <> field_name <> ": " <> value <> ",\n")
            False -> Error(Nil)
          }
        }
        lexer.BoolAttr(name) -> {
          // Boolean attribute sets prop to True if it matches an expected prop
          let field_name = to_field_name(name)
          case list.contains(expected_prop_names, field_name) {
            True -> Ok(pad <> field_name <> ": True,\n")
            False -> Error(Nil)
          }
        }
        lexer.StringAttr(_, _) -> Error(Nil)
        lexer.ClassAttr(_) -> Error(Nil)
        lexer.StyleAttr(_) -> Error(Nil)
        lexer.LmIf(_) | lexer.LmElseIf(_) | lexer.LmElse | lexer.LmFor(_, _, _) ->
          Error(Nil)
      }
    })
    |> string.join("")

  // Look up component's expected props and generate defaults for missing ones
  let default_props_code = case dict.get(component_data, component_name) {
    Error(_) -> ""
    Ok(expected_props) -> {
      expected_props
      |> list.filter_map(fn(prop) {
        let #(prop_name, prop_type) = prop
        // Skip if explicitly provided
        case list.contains(explicit_props, prop_name) {
          True -> Error(Nil)
          False -> {
            // Generate default value based on type
            let default_value = default_for_type(prop_type)
            Ok(pad <> prop_name <> ": " <> default_value <> ",\n")
          }
        }
      })
      |> string.join("")
    }
  }

  let props_code = explicit_props_code <> default_props_code

  // Generate attributes list for pass-through
  // Exclude expression/boolean attributes that are props (they're handled above)
  // Each attribute type handled independently (no class/style merging)
  let attrs_items =
    attributes
    |> list.filter_map(fn(attr) {
      case attr {
        lexer.StringAttr(name, value) ->
          Ok(
            "runtime.Attribute(\""
            <> name
            <> "\", \""
            <> escape_gleam_string(value)
            <> "\")",
          )
        lexer.ExprAttr(name, value) -> {
          // Only include as HTML attribute if NOT a prop
          let field_name = to_field_name(name)
          case list.contains(expected_prop_names, field_name) {
            True -> Error(Nil)
            // It's a prop, not an HTML attribute
            False -> {
              // Use BoolAttribute for known HTML boolean attributes
              case is_html_boolean_attribute(name) {
                True ->
                  Ok(
                    "runtime.BoolAttribute(\"" <> name <> "\", " <> value <> ")",
                  )
                False ->
                  Ok("runtime.Attribute(\"" <> name <> "\", " <> value <> ")")
              }
            }
          }
        }
        lexer.BoolAttr(name) -> {
          // Only include as HTML attribute if NOT a prop
          let field_name = to_field_name(name)
          case list.contains(expected_prop_names, field_name) {
            True -> Error(Nil)
            // It's a prop, not an HTML attribute
            False ->
              Ok("runtime.Attribute(\"" <> name <> "\", \"" <> name <> "\")")
          }
        }
        lexer.ClassAttr(value) ->
          Ok(
            "runtime.Attribute(\"class\", runtime.build_classes("
            <> transform_class_list(value)
            <> "))",
          )
        lexer.StyleAttr(value) ->
          Ok(
            "runtime.Attribute(\"style\", runtime.build_styles("
            <> transform_style_list(value)
            <> "))",
          )
        lexer.LmIf(_) | lexer.LmElseIf(_) | lexer.LmElse | lexer.LmFor(_, _, _) ->
          Error(Nil)
      }
    })

  let extra_attrs_code = case attrs_items {
    [] -> "[]"
    items -> "[" <> string.join(items, ", ") <> "]"
  }

  #(props_code, extra_attrs_code)
}

/// Returns a default value for a Gleam type. Handles Bool,
/// String, Int, Float, Option, and List types with sensible
/// defaults.
///
fn default_for_type(type_str: String) -> String {
  case type_str {
    "Bool" -> "False"
    "String" -> "\"\""
    "Int" -> "0"
    "Float" -> "0.0"
    _ -> {
      // For Option types, default to None
      case string.starts_with(type_str, "Option(") {
        True -> "None"
        False -> {
          // For List types, default to empty list
          case string.starts_with(type_str, "List(") {
            True -> "[]"
            // Unknown type - can't provide a default
            False -> "todo"
          }
        }
      }
    }
  }
}

/// Checks if an attribute name is an HTML boolean attribute.
/// These attributes render only their name when true, not
/// name="value" pairs.
///
fn is_html_boolean_attribute(name: String) -> Bool {
  case name {
    "disabled"
    | "checked"
    | "readonly"
    | "required"
    | "hidden"
    | "selected"
    | "multiple"
    | "autofocus"
    | "autoplay"
    | "controls"
    | "loop"
    | "muted"
    | "default"
    | "defer"
    | "async"
    | "novalidate"
    | "formnovalidate"
    | "ismap"
    | "nomodule"
    | "playsinline"
    | "open"
    | "reversed"
    | "allowfullscreen"
    | "inert"
    | "itemscope" -> True
    _ -> False
  }
}

/// Generates named slot arguments for a component call. Each
/// slot definition becomes an inline block expression that
/// renders the slot content.
///
fn generate_component_named_slots(
  component_name: String,
  named_slots: List(#(Option(String), List(Node))),
  indent: Int,
  component_data: ComponentDataMap,
  component_slots: ComponentSlotMap,
) -> String {
  let pad = string.repeat("  ", indent)

  // Filter to only named slots (Some(name)), not default slot definitions
  let actual_named_slots =
    list.filter_map(named_slots, fn(slot) {
      case slot.0 {
        Some(name) -> Ok(#(name, slot.1))
        None -> Error(Nil)
      }
    })

  // Get the names of slots that are explicitly provided
  let provided_slot_names =
    list.map(actual_named_slots, fn(slot) { slot.0 }) |> set.from_list

  // Get all named slots the component expects
  let expected_slots = case dict.get(component_slots, component_name) {
    Ok(info) -> info.named_slots
    Error(_) -> []
  }

  // Generate code for explicitly provided slots
  let provided_slots_code =
    actual_named_slots
    |> list.map(fn(slot) {
      let #(name, children) = slot
      let slot_code =
        generate_nodes_code(
          children,
          indent + 2,
          component_data,
          component_slots,
        )
      pad
      <> "slot_"
      <> to_field_name(name)
      <> ": {\n"
      <> pad
      <> "  \"\"\n"
      <> slot_code
      <> pad
      <> "},\n"
    })
    |> string.join("")

  // Generate empty strings for missing slots
  let missing_slots_code =
    expected_slots
    |> list.filter(fn(name) { !set.contains(provided_slot_names, name) })
    |> list.map(fn(name) {
      pad <> "slot_" <> to_field_name(name) <> ": \"\",\n"
    })
    |> string.join("")

  provided_slots_code <> missing_slots_code
}

/// Generates code for element attributes. Converts lexer
/// attributes to runtime calls for rendering HTML attributes.
///
fn generate_element_attrs_code(attrs: List(lexer.ComponentAttr)) -> String {
  case attrs {
    [] -> ""
    _ -> {
      let attr_items =
        attrs
        |> list.filter_map(fn(attr) {
          case attr {
            lexer.StringAttr(name, value) ->
              Ok(
                "runtime.Attribute(\""
                <> name
                <> "\", \""
                <> escape_gleam_string(value)
                <> "\")",
              )
            lexer.ExprAttr(name, value) -> {
              case is_html_boolean_attribute(name) {
                True ->
                  Ok(
                    "runtime.BoolAttribute(\"" <> name <> "\", " <> value <> ")",
                  )
                False ->
                  Ok("runtime.Attribute(\"" <> name <> "\", " <> value <> ")")
              }
            }
            lexer.BoolAttr(name) ->
              Ok("runtime.Attribute(\"" <> name <> "\", \"" <> name <> "\")")
            lexer.ClassAttr(value) ->
              Ok(
                "runtime.Attribute(\"class\", runtime.build_classes("
                <> transform_class_list(value)
                <> "))",
              )
            lexer.StyleAttr(value) ->
              Ok(
                "runtime.Attribute(\"style\", runtime.build_styles("
                <> transform_style_list(value)
                <> "))",
              )
            // l-* attributes should already be filtered out by parser
            lexer.LmIf(_)
            | lexer.LmElseIf(_)
            | lexer.LmElse
            | lexer.LmFor(_, _, _) -> Error(Nil)
          }
        })

      case attr_items {
        [] -> ""
        items ->
          "  <> \" \" <> runtime.render_attributes(["
          <> string.join(items, ", ")
          <> "])\n"
      }
    }
  }
}

/// Checks if a tag is an HTML void element. Void elements like
/// img, br, and input are self-closing and cannot contain
/// children in HTML.
///
fn is_void_element(tag: String) -> Bool {
  case tag {
    "area"
    | "base"
    | "br"
    | "col"
    | "embed"
    | "hr"
    | "img"
    | "input"
    | "link"
    | "meta"
    | "param"
    | "source"
    | "track"
    | "wbr" -> True
    _ -> False
  }
}

/// Generates code for base attributes. Converts lexer
/// attributes to runtime Attribute constructors.
///
fn generate_base_attrs_code(attrs: List(lexer.ComponentAttr)) -> String {
  let items =
    attrs
    |> list.filter_map(fn(attr) {
      case attr {
        lexer.StringAttr(name, value) ->
          Ok(
            "runtime.Attribute(\""
            <> name
            <> "\", \""
            <> escape_gleam_string(value)
            <> "\")",
          )
        lexer.BoolAttr(name) ->
          Ok("runtime.Attribute(\"" <> name <> "\", \"" <> name <> "\")")
        lexer.ExprAttr(name, value) ->
          Ok("runtime.Attribute(\"" <> name <> "\", " <> value <> ")")
        lexer.ClassAttr(value) ->
          Ok(
            "runtime.Attribute(\"class\", runtime.build_classes("
            <> transform_class_list(value)
            <> "))",
          )
        lexer.StyleAttr(value) ->
          Ok(
            "runtime.Attribute(\"style\", runtime.build_styles("
            <> transform_style_list(value)
            <> "))",
          )
        lexer.LmIf(_) | lexer.LmElseIf(_) | lexer.LmElse | lexer.LmFor(_, _, _) ->
          Error(Nil)
      }
    })

  "[" <> string.join(items, ", ") <> "]"
}

/// Checks if the template contains an @attributes directive.
/// Recursively searches the AST to find explicit attribute
/// injection points.
///
fn has_attributes_node(nodes: List(Node)) -> Bool {
  list.any(nodes, fn(node) {
    case node {
      parser.AttributesNode(_) -> True
      parser.IfNode(branches) ->
        list.any(branches, fn(branch) { has_attributes_node(branch.1) })
      parser.EachNode(_, _, _, body) -> has_attributes_node(body)
      parser.SlotDefNode(_, children) -> has_attributes_node(children)
      parser.ComponentNode(_, _, children) -> has_attributes_node(children)
      parser.ElementNode(_, _, children) -> has_attributes_node(children)
      _ -> False
    }
  })
}

/// Injects @attributes into the first HTML element. For
/// components without explicit attribute placement, adds
/// attributes to the root element automatically.
///
fn inject_attributes_into_first_element(nodes: List(Node)) -> List(Node) {
  inject_attributes_helper(nodes, False).0
}

/// Recursive helper for attribute injection. Searches for the
/// first HTML tag and inserts an AttributesNode after its
/// opening bracket and existing attributes.
///
fn inject_attributes_helper(
  nodes: List(Node),
  injected: Bool,
) -> #(List(Node), Bool) {
  case injected, nodes {
    True, _ -> #(nodes, True)
    False, [] -> #([], False)
    False, [parser.TextNode(text), ..rest] -> {
      case find_first_tag_and_extract_attrs(text) {
        Some(#(before_attrs, base_attrs, after)) -> {
          let new_nodes = [
            parser.TextNode(before_attrs),
            parser.AttributesNode(base_attrs),
            parser.TextNode(after),
            ..rest
          ]
          #(new_nodes, True)
        }
        None -> {
          let #(rest_nodes, did_inject) = inject_attributes_helper(rest, False)
          #([parser.TextNode(text), ..rest_nodes], did_inject)
        }
      }
    }
    // Recurse into IfNode to find first element inside conditionals
    False, [parser.IfNode(branches), ..rest] -> {
      let #(new_branches, did_inject) =
        inject_attributes_into_branches(branches, False)
      case did_inject {
        True -> #([parser.IfNode(new_branches), ..rest], True)
        False -> {
          let #(rest_nodes, rest_inject) = inject_attributes_helper(rest, False)
          #([parser.IfNode(new_branches), ..rest_nodes], rest_inject)
        }
      }
    }
    // Recurse into EachNode to find first element inside loops
    False, [parser.EachNode(collection, items, loop_var, body), ..rest] -> {
      let #(new_body, did_inject) = inject_attributes_helper(body, False)
      case did_inject {
        True -> #(
          [parser.EachNode(collection, items, loop_var, new_body), ..rest],
          True,
        )
        False -> {
          let #(rest_nodes, rest_inject) = inject_attributes_helper(rest, False)
          #(
            [
              parser.EachNode(collection, items, loop_var, new_body),
              ..rest_nodes
            ],
            rest_inject,
          )
        }
      }
    }
    // For ElementNode, inject AttributesNode into its children
    False, [parser.ElementNode(tag, attrs, children), ..rest] -> {
      let new_children = [parser.AttributesNode(attrs), ..children]
      #([parser.ElementNode(tag, [], new_children), ..rest], True)
    }
    False, [node, ..rest] -> {
      let #(rest_nodes, did_inject) = inject_attributes_helper(rest, False)
      #([node, ..rest_nodes], did_inject)
    }
  }
}

/// Injects @attributes into branches of an if/elseif/else.
/// Processes each branch body looking for the first HTML tag
/// and returns updated branches with injection status.
///
fn inject_attributes_into_branches(
  branches: List(#(Option(String), List(Node))),
  injected: Bool,
) -> #(List(#(Option(String), List(Node))), Bool) {
  case branches {
    [] -> #([], injected)
    [#(condition, body), ..rest] -> {
      let #(new_body, did_inject) = inject_attributes_helper(body, injected)
      let #(rest_branches, rest_inject) =
        inject_attributes_into_branches(rest, did_inject)
      #([#(condition, new_body), ..rest_branches], rest_inject)
    }
  }
}

/// Finds the first HTML tag in text and extracts attributes.
/// Returns the text before attributes, parsed attributes,
/// and the closing portion of the tag.
///
fn find_first_tag_and_extract_attrs(
  text: String,
) -> Option(#(String, List(lexer.ComponentAttr), String)) {
  case string.split_once(text, "<") {
    Error(_) -> None
    Ok(#(before_tag, after_open)) -> {
      case parse_tag_content(after_open) {
        Some(#(tag_name, attrs, closing)) -> {
          Some(#(before_tag <> "<" <> tag_name <> " ", attrs, closing))
        }
        None -> None
      }
    }
  }
}

/// Parses the content after an opening angle bracket. Extracts
/// the tag name and parses any attributes before the closing
/// bracket.
///
fn parse_tag_content(
  content: String,
) -> Option(#(String, List(lexer.ComponentAttr), String)) {
  let content = string.trim_start(content)
  let #(tag_name, rest) = take_until_space_or_close(content, "")

  case tag_name {
    "" -> None
    "/" <> _ -> None
    "!" <> _ -> None
    _ -> {
      let #(attrs, closing) = parse_html_attributes(string.trim_start(rest), [])
      Some(#(tag_name, attrs, closing))
    }
  }
}

/// Reads characters until whitespace or tag delimiter. Used
/// to extract tag names and unquoted attribute values from
/// HTML content.
///
fn take_until_space_or_close(input: String, acc: String) -> #(String, String) {
  case string.pop_grapheme(input) {
    Error(_) -> #(acc, "")
    Ok(#(char, rest)) -> {
      case char {
        " " | "\t" | "\n" | "\r" | ">" | "/" -> #(acc, input)
        _ -> take_until_space_or_close(rest, acc <> char)
      }
    }
  }
}

/// Parses HTML attributes from an opening tag. Continues until
/// the closing bracket, accumulating string and boolean
/// attributes.
///
fn parse_html_attributes(
  input: String,
  acc: List(lexer.ComponentAttr),
) -> #(List(lexer.ComponentAttr), String) {
  let input = string.trim_start(input)

  case string.pop_grapheme(input) {
    Error(_) -> #(list.reverse(acc), "")
    Ok(#(">", rest)) -> #(list.reverse(acc), ">" <> rest)
    Ok(#("/", rest)) -> {
      case string.first(rest) {
        Ok(">") -> #(list.reverse(acc), "/" <> rest)
        _ -> #(list.reverse(acc), "/" <> rest)
      }
    }
    Ok(#(_, _)) -> {
      case parse_single_html_attribute(input) {
        Some(#(attr, remaining)) ->
          parse_html_attributes(remaining, [attr, ..acc])
        None ->
          case string.pop_grapheme(input) {
            Ok(#(_, rest)) -> parse_html_attributes(rest, acc)
            Error(_) -> #(list.reverse(acc), "")
          }
      }
    }
  }
}

/// Parses a single HTML attribute. Handles name="value" with
/// single or double quotes, unquoted values, and boolean
/// attributes without values.
///
fn parse_single_html_attribute(
  input: String,
) -> Option(#(lexer.ComponentAttr, String)) {
  let input = string.trim_start(input)
  let #(name, rest) = take_attr_name(input, "")

  case name {
    "" -> None
    _ -> {
      let rest = string.trim_start(rest)
      case string.pop_grapheme(rest) {
        Ok(#("=", after_eq)) -> {
          let after_eq = string.trim_start(after_eq)
          case string.pop_grapheme(after_eq) {
            Ok(#("\"", after_quote)) -> {
              let #(value, remaining) = take_until_char(after_quote, "\"", "")
              Some(#(lexer.StringAttr(name, value), remaining))
            }
            Ok(#("'", after_quote)) -> {
              let #(value, remaining) = take_until_char(after_quote, "'", "")
              Some(#(lexer.StringAttr(name, value), remaining))
            }
            Ok(#(_, _)) -> {
              let #(value, remaining) = take_until_space_or_close(after_eq, "")
              Some(#(lexer.StringAttr(name, value), remaining))
            }
            Error(_) -> Some(#(lexer.BoolAttr(name), rest))
          }
        }
        _ -> Some(#(lexer.BoolAttr(name), rest))
      }
    }
  }
}

/// Extracts an attribute name from input. Reads until
/// whitespace, equals sign, or tag delimiter is encountered,
/// returning the name and remaining input.
///
fn take_attr_name(input: String, acc: String) -> #(String, String) {
  case string.pop_grapheme(input) {
    Error(_) -> #(acc, "")
    Ok(#(char, rest)) -> {
      case char {
        " " | "\t" | "\n" | "\r" | "=" | ">" | "/" -> #(acc, input)
        _ -> take_attr_name(rest, acc <> char)
      }
    }
  }
}

/// Reads characters until a specific stop character is found.
/// Used to extract quoted attribute values by reading until
/// the closing quote.
///
fn take_until_char(
  input: String,
  stop_char: String,
  acc: String,
) -> #(String, String) {
  case string.pop_grapheme(input) {
    Error(_) -> #(acc, "")
    Ok(#(char, rest)) -> {
      case char == stop_char {
        True -> #(acc, rest)
        False -> take_until_char(rest, stop_char, acc <> char)
      }
    }
  }
}

/// Converts a name to a valid Gleam field name. Replaces
/// dashes, colons, and spaces with underscores and converts
/// to snake_case.
///
fn to_field_name(name: String) -> String {
  name
  |> string.replace("-", "_")
  |> string.replace(":", "_")
  |> string.replace(" ", "_")
  |> to_snake_case
}

/// Converts a string to snake_case. Inserts underscores before
/// uppercase letters and lowercases them, then strips any
/// leading underscores.
///
fn to_snake_case(input: String) -> String {
  input
  |> string.to_graphemes
  |> list.fold("", fn(acc, char) {
    case is_uppercase(char) {
      True -> acc <> "_" <> string.lowercase(char)
      False -> acc <> char
    }
  })
  |> strip_leading_underscores
}

/// Removes leading underscores from a string. Used to clean
/// up snake_case conversions that produce strings starting
/// with underscores.
///
fn strip_leading_underscores(input: String) -> String {
  case input {
    "_" <> rest -> strip_leading_underscores(rest)
    _ -> input
  }
}

/// Checks if a character is uppercase. Compares the character
/// to its uppercase version to determine case, excluding
/// characters that are the same in both cases.
///
fn is_uppercase(char: String) -> Bool {
  let upper = string.uppercase(char)
  char == upper && char != string.lowercase(char)
}

/// Escapes a string for use in generated Gleam code. Handles
/// backslashes, quotes, newlines, carriage returns, and tabs
/// with proper escape sequences.
///
fn escape_gleam_string(input: String) -> String {
  input
  |> string.replace("\\", "\\\\")
  |> string.replace("\"", "\\\"")
  |> string.replace("\n", "\\n")
  |> string.replace("\r", "\\r")
  |> string.replace("\t", "\\t")
}

/// Generates a module alias for a component import. Converts
/// the component name to a valid Gleam identifier by replacing
/// colons and dashes with underscores.
///
fn component_module_alias(name: String) -> String {
  "components_"
  <> name
  |> string.replace(":", "_")
  |> string.replace("-", "_")
}

/// Formats the items pattern for an each loop. Single items
/// are returned as-is, while multiple items are wrapped in
/// a tuple pattern like #(key, value).
///
fn format_each_items_pattern(items: List(String)) -> String {
  case items {
    [single] -> single
    multiple -> "#(" <> string.join(multiple, ", ") <> ")"
  }
}

/// Transforms string literals in a :class list to use the
/// runtime.class() helper. Converts ["foo", #("bar", cond)]
/// to [runtime.class("foo"), #("bar", cond)].
///
fn transform_class_list(value: String) -> String {
  transform_list_strings(value, "runtime.class")
}

/// Transforms string literals in a :style list to use the
/// runtime.style() helper. Converts ["foo", #("bar", cond)]
/// to [runtime.style("foo"), #("bar", cond)].
///
fn transform_style_list(value: String) -> String {
  transform_list_strings(value, "runtime.style")
}

/// Transforms bare string literals at the top level of a list
/// to wrap them with a helper function. Tuples and nested
/// expressions like #("x", cond) are left unchanged.
///
fn transform_list_strings(value: String, wrapper: String) -> String {
  let chars = string.to_graphemes(value)
  transform_list_chars(chars, wrapper, 0, False, "", "")
}

/// Recursive helper for transforming list string literals.
/// Tracks nesting depth and string state to identify top-level
/// string literals that need wrapping with the helper function.
///
fn transform_list_chars(
  chars: List(String),
  wrapper: String,
  depth: Int,
  in_string: Bool,
  current: String,
  result: String,
) -> String {
  case in_string, chars {
    _, [] -> result <> current
    True, ["\\", c, ..rest] -> {
      // Escaped character in string - keep both
      transform_list_chars(
        rest,
        wrapper,
        depth,
        True,
        current <> "\\" <> c,
        result,
      )
    }
    True, ["\"", ..rest] -> {
      // End of string
      transform_list_chars(rest, wrapper, depth, False, current <> "\"", result)
    }
    True, [c, ..rest] -> {
      // Inside string - just accumulate
      transform_list_chars(rest, wrapper, depth, True, current <> c, result)
    }
    False, ["\"", ..rest] -> {
      // Start of string at current depth
      case depth {
        1 -> {
          // Top level of list - wrap with helper
          transform_list_chars(
            rest,
            wrapper,
            depth,
            True,
            wrapper <> "(\"",
            result <> current,
          )
        }
        _ -> {
          // Inside tuple or nested - don't wrap
          transform_list_chars(
            rest,
            wrapper,
            depth,
            True,
            current <> "\"",
            result,
          )
        }
      }
    }
    False, ["[", ..rest] -> {
      transform_list_chars(
        rest,
        wrapper,
        depth + 1,
        False,
        current <> "[",
        result,
      )
    }
    False, ["]", ..rest] -> {
      // Check if we need to close the wrapper before ]
      let needs_close =
        depth == 1 && string.starts_with(current, wrapper <> "(")
      let new_current = case needs_close {
        True -> current <> ")"
        False -> current
      }
      transform_list_chars(
        rest,
        wrapper,
        depth - 1,
        False,
        new_current <> "]",
        result,
      )
    }
    False, ["(", ..rest] -> {
      transform_list_chars(
        rest,
        wrapper,
        depth + 1,
        False,
        current <> "(",
        result,
      )
    }
    False, [")", ..rest] -> {
      transform_list_chars(
        rest,
        wrapper,
        depth - 1,
        False,
        current <> ")",
        result,
      )
    }
    False, [",", ..rest] -> {
      // Comma at depth 1 means end of list item - flush and check if wrapper needed
      let needs_close =
        depth == 1 && string.starts_with(current, wrapper <> "(")
      let new_current = case needs_close {
        True -> current <> ")"
        False -> current
      }
      transform_list_chars(
        rest,
        wrapper,
        depth,
        False,
        "",
        result <> new_current <> ",",
      )
    }
    False, [c, ..rest] -> {
      transform_list_chars(rest, wrapper, depth, False, current <> c, result)
    }
  }
}
