//// Code Generator
////
//// Generates typed Gleam repository modules from parsed schema
//// definitions and SQL query files. Produces complete,
//// formatted Gleam code including:
////
//// - Model type definitions matching the schema
//// - Decoder functions for database rows
//// - Query functions for each SQL file (returning Results)
//// - Row types for queries with custom SELECT columns

import gleam/int
import gleam/list
import gleam/option.{None, Some}
import gleam/string
import glimr/db/gen/parser.{type ParsedQuery}
import glimr/db/gen/parser/columns.{type SelectedColumn}
import glimr/db/gen/schema_parser.{type ColumnType, type Table}
import glimr/db/gen/schema_parser/codegen

// ------------------------------------------------------------- Public Functions

/// Generates a complete Gleam repository module for a model.
/// Combines the header, imports, model type, decoder, and all
/// query functions into a single module string.
///
/// The driver_type parameter should be "sqlite" or "postgres" 
/// to generate driver-specific imports and function calls.
///
pub fn generate(
  model_name: String,
  table: Table,
  queries: List(#(String, String, ParsedQuery)),
  driver_type: String,
) -> String {
  let header = generate_header(model_name)
  let imports = generate_imports(table, driver_type)
  let model_type = generate_model_type(model_name, table)
  let model_decoder = generate_model_decoder(model_name, table)
  let query_code = generate_queries(model_name, table, queries, driver_type)

  string.join([header, imports, model_type, model_decoder, query_code], "\n\n")
}

// ------------------------------------------------------------- Private Functions

/// Generates the module documentation comment with a warning
/// that the file is auto-generated and should not be edited
/// manually by developers.
///
fn generate_header(model_name: String) -> String {
  "//// "
  <> pascal_case(model_name)
  <> " Model (GENERATED - DO NOT EDIT)\n////\n//// Generated by Glimr âœ¨"
}

/// Generates the import statements for the repository module.
/// Conditionally includes Option and glimr_decode imports based
/// on whether the schema has nullable or boolean columns.
///
/// Generates driver-specific imports based on driver_type.
///
fn generate_imports(table: Table, driver_type: String) -> String {
  let columns = schema_parser.columns(table)
  let has_boolean =
    list.any(columns, fn(col) { col.column_type == schema_parser.Boolean })
  let has_nullable = list.any(columns, fn(col) { col.nullable })

  let list_import = case driver_type {
    "sqlite" -> "\nimport gleam/list"
    _ -> ""
  }

  let base_imports = "import gleam/dynamic/decode" <> list_import

  let option_import = case has_nullable {
    True -> "\nimport gleam/option.{type Option}"
    False -> ""
  }

  let glimr_decode_import = case has_boolean {
    True -> "\nimport glimr/db/decode as glimr_decode"
    False -> ""
  }

  // Driver-specific imports (both wrapper module and native driver)
  let driver_import = case driver_type {
    "sqlite" -> "\nimport glimr_sqlite/db/pool\nimport sqlight"
    "postgres" -> "\nimport glimr_postgres/db/pool\nimport pog"
    _ -> "\nimport glimr_sqlite/db/pool\nimport sqlight"
  }

  // Import pool_connection for error constructors (NotFound, QueryError)
  let error_import = "\nimport glimr/db/pool_connection.{NotFound, QueryError}"

  base_imports
  <> option_import
  <> glimr_decode_import
  <> driver_import
  <> error_import
}

/// Generates the main model type definition from the schema.
/// Maps column types to Gleam types and wraps nullable columns
/// in Option.
///
fn generate_model_type(model_name: String, table: Table) -> String {
  let type_name = pascal_case(model_name)
  let columns = schema_parser.columns(table)

  let fields =
    list.map(columns, fn(col) {
      let gleam_type = codegen.gleam_type(col.column_type)
      let type_str = case col.nullable {
        True -> "Option(" <> gleam_type <> ")"
        False -> gleam_type
      }
      "    " <> col.name <> ": " <> type_str
    })

  "pub type "
  <> type_name
  <> " {\n  "
  <> type_name
  <> "(\n"
  <> string.join(fields, ",\n")
  <> ",\n  )\n}"
}

/// Generates the public decoder function for the main model 
/// type. Creates field decoders for each column with proper 
/// handling of nullable fields using decode.optional.
///
fn generate_model_decoder(model_name: String, table: Table) -> String {
  let type_name = pascal_case(model_name)
  let columns = schema_parser.columns(table)

  let field_decoders =
    list.index_map(columns, fn(col, idx) {
      let decoder = codegen.decoder_fn(col.column_type)
      let decoder_with_nullable = case col.nullable {
        True -> "decode.optional(" <> decoder <> ")"
        False -> decoder
      }
      "  use "
      <> col.name
      <> " <- decode.field("
      <> int.to_string(idx)
      <> ", "
      <> decoder_with_nullable
      <> ")"
    })

  let field_names = list.map(columns, fn(col) { col.name })
  let constructor_call =
    type_name <> "(" <> string.join(field_names, ", ") <> ")"

  "pub fn decoder() -> decode.Decoder("
  <> type_name
  <> ") {\n"
  <> string.join(field_decoders, "\n")
  <> "\n"
  <> "  decode.success("
  <> constructor_call
  <> ")\n}"
}

/// Generates code for all query functions by mapping over the
/// list of parsed queries and joining the results with blank
/// lines between each function.
///
fn generate_queries(
  model_name: String,
  table: Table,
  queries: List(#(String, String, ParsedQuery)),
  driver_type: String,
) -> String {
  let query_codes =
    list.map(queries, fn(query_tuple) {
      let #(query_name, sql, parsed) = query_tuple
      generate_single_query(
        model_name,
        table,
        query_name,
        sql,
        parsed,
        driver_type,
      )
    })

  string.join(query_codes, "\n\n")
}

/// Generates code for a single SQL query. For queries with no
/// SELECT columns, generates an execute-style function. For
/// queries with columns, generates a row type, decoder, and
/// query function with both callback and _or variants.
///
fn generate_single_query(
  model_name: String,
  table: Table,
  query_name: String,
  sql: String,
  parsed: ParsedQuery,
  driver_type: String,
) -> String {
  let fn_name = snake_case(query_name)

  let columns_with_types = resolve_column_types(table, parsed.columns)

  let param_types = resolve_param_types(table, parsed.param_columns)

  case list.is_empty(columns_with_types) {
    True -> {
      generate_execute_function(
        fn_name,
        sql,
        parsed.params,
        param_types,
        driver_type,
      )
    }
    False -> {
      // Build model column signature for comparison
      let model_columns =
        list.map(schema_parser.columns(table), fn(col) {
          #(col.name, col.column_type, col.nullable)
        })

      // Check if query columns match the model exactly
      let matches_model = columns_with_types == model_columns

      case matches_model {
        True -> {
          // Reuse the model type and public decoder()
          let type_name = pascal_case(model_name)
          let query_fn =
            generate_query_function(
              fn_name,
              type_name,
              sql,
              parsed.params,
              columns_with_types,
              param_types,
              driver_type,
              True,
            )
          query_fn
        }
        False -> {
          // Create a query-specific type named {Query}{Model}
          let type_name = pascal_case(query_name) <> pascal_case(model_name)

          let row_type = generate_row_type(type_name, columns_with_types)

          let row_decoder = generate_row_decoder(type_name, columns_with_types)

          let query_fn =
            generate_query_function(
              fn_name,
              type_name,
              sql,
              parsed.params,
              columns_with_types,
              param_types,
              driver_type,
              False,
            )

          string.join([row_type, row_decoder, query_fn], "\n\n")
        }
      }
    }
  }
}

/// Maps parameter placeholders to their types from the schema.
/// Strips start_/end_ prefixes for BETWEEN parameters when
/// looking up the column type.
///
fn resolve_param_types(
  table: Table,
  param_columns: List(#(Int, String)),
) -> List(#(Int, String, ColumnType)) {
  let schema_columns = schema_parser.columns(table)

  list.filter_map(param_columns, fn(pc) {
    let #(param_num, col_name) = pc
    // Strip start_/end_ prefixes for BETWEEN params when looking up type
    let lookup_name = case string.starts_with(col_name, "start_") {
      True -> string.drop_start(col_name, 6)
      False ->
        case string.starts_with(col_name, "end_") {
          True -> string.drop_start(col_name, 4)
          False -> col_name
        }
    }
    case list.find(schema_columns, fn(sc) { sc.name == lookup_name }) {
      Ok(col) -> Ok(#(param_num, col_name, col.column_type))
      Error(_) -> Error(Nil)
    }
  })
}

/// Maps selected columns to their types from the schema. 
/// Handles star (*) expansion to all schema columns, alias 
/// resolution, and aggregate function type inference.
///
fn resolve_column_types(
  table: Table,
  columns: List(SelectedColumn),
) -> List(#(String, ColumnType, Bool)) {
  let schema_columns = schema_parser.columns(table)

  // Check if there's a * (star) select - expand to all schema columns
  let has_star = list.any(columns, fn(sel_col) { sel_col.name == "*" })

  case has_star {
    True -> {
      // Expand * to all schema columns
      list.map(schema_columns, fn(col) {
        #(col.name, col.column_type, col.nullable)
      })
    }
    False -> {
      list.map(columns, fn(sel_col) {
        let name = case sel_col.alias {
          Some(alias) -> alias
          None -> sel_col.name
        }

        // First check if it's an aggregate function
        case infer_aggregate_type(sel_col.name) {
          Some(agg_type) -> #(name, agg_type, False)
          None -> {
            // Find matching column in schema
            let schema_col =
              list.find(schema_columns, fn(sc) { sc.name == sel_col.name })

            case schema_col {
              Ok(col) -> #(name, col.column_type, col.nullable)
              Error(_) -> #(name, schema_parser.String, False)
              // Default to String if not found
            }
          }
        }
      })
    }
  }
}

/// Infers the return type for SQL aggregate functions. COUNT
/// and SUM return Int, AVG returns Float. Returns None for
/// non-aggregate expressions.
///
fn infer_aggregate_type(expr: String) -> option.Option(ColumnType) {
  let upper = string.uppercase(expr)

  // COUNT always returns Int
  case string.starts_with(upper, "COUNT(") {
    True -> Some(schema_parser.Int)
    False -> {
      // SUM typically returns Int (could be Float for float columns)
      case string.starts_with(upper, "SUM(") {
        True -> Some(schema_parser.Int)
        False -> {
          // AVG returns Float
          case string.starts_with(upper, "AVG(") {
            True -> Some(schema_parser.Float)
            False -> None
          }
        }
      }
    }
  }
}

/// Generates a row type for a query's SELECT columns. Similar
/// to generate_model_type but creates query-specific result
/// types with only the selected columns.
///
fn generate_row_type(
  type_name: String,
  columns: List(#(String, ColumnType, Bool)),
) -> String {
  let fields =
    list.map(columns, fn(col_tuple) {
      let #(name, col_type, nullable) = col_tuple
      let gleam_type = codegen.gleam_type(col_type)
      let type_str = case nullable {
        True -> "Option(" <> gleam_type <> ")"
        False -> gleam_type
      }
      "    " <> name <> ": " <> type_str
    })

  "pub type "
  <> type_name
  <> " {\n  "
  <> type_name
  <> "(\n"
  <> string.join(fields, ",\n")
  <> ",\n  )\n}"
}

/// Generates a private decoder function for a query's row type.
/// Creates field decoders by index position with nullable 
/// handling.
///
fn generate_row_decoder(
  type_name: String,
  columns: List(#(String, ColumnType, Bool)),
) -> String {
  let field_decoders =
    list.index_map(columns, fn(col_tuple, idx) {
      let #(name, col_type, nullable) = col_tuple
      let decoder = codegen.decoder_fn(col_type)
      let decoder_with_nullable = case nullable {
        True -> "decode.optional(" <> decoder <> ")"
        False -> decoder
      }
      "  use "
      <> name
      <> " <- decode.field("
      <> int.to_string(idx)
      <> ", "
      <> decoder_with_nullable
      <> ")"
    })

  let field_names =
    list.map(columns, fn(col_tuple) {
      let #(name, _, _) = col_tuple
      name
    })
  let constructor_call =
    type_name <> "(" <> string.join(field_names, ", ") <> ")"

  "fn "
  <> snake_case(type_name)
  <> "_decoder() -> decode.Decoder("
  <> type_name
  <> ") {\n"
  <> string.join(field_decoders, "\n")
  <> "\n"
  <> "  decode.success("
  <> constructor_call
  <> ")\n}"
}

/// Generates two query functions: the main function accepts a
/// Pool and uses get_connection, while the _wc (with
/// connection) variant accepts a Connection for use in
/// transactions. Handles both single-row and list queries.
///
fn generate_query_function(
  fn_name: String,
  row_type_name: String,
  sql: String,
  params: List(Int),
  _columns: List(#(String, ColumnType, Bool)),
  param_types: List(#(Int, String, ColumnType)),
  driver_type: String,
  uses_model_decoder: Bool,
) -> String {
  let param_count = list.length(params)

  // Get driver module name
  let driver_module = driver_module_name(driver_type)

  // Detect if this is a multi-row query (list_*) or single-row (everything else)
  let is_single_row = !string.starts_with(fn_name, "list_")

  // Generate parameter list with proper types and labeled names
  let param_list = case param_count {
    0 -> ""
    _ ->
      ", "
      <> string.join(
        int.range(from: 1, to: param_count + 1, with: [], run: fn(acc, n) {
          [
            case list.find(param_types, fn(pt) { pt.0 == n }) {
              Ok(#(_, col_name, col_type)) -> {
                let gleam_type = codegen.gleam_type(col_type)
                col_name <> " " <> col_name <> ": " <> gleam_type
              }
              Error(_) -> {
                let name = "p" <> int.to_string(n)
                name <> " " <> name <> ": String"
              }
            },
            ..acc
          ]
        })
          |> list.reverse,
        ", ",
      )
  }

  // Generate parameter values with native wrappers for _wc functions
  let native_param_values = case param_count {
    0 -> "[]"
    _ ->
      "["
      <> string.join(
        int.range(from: 1, to: param_count + 1, with: [], run: fn(acc, n) {
          [
            case list.find(param_types, fn(pt) { pt.0 == n }) {
              Ok(#(_, col_name, col_type)) -> {
                let wrapper = native_wrapper(col_type, driver_type)
                wrapper <> "(" <> col_name <> ")"
              }
              Error(_) ->
                native_string_wrapper(driver_type)
                <> "(p"
                <> int.to_string(n)
                <> ")"
            },
            ..acc
          ]
        })
          |> list.reverse,
        ", ",
      )
      <> "]"
  }

  // Generate param names for passing to _wc function (with labels)
  let param_names = case param_count {
    0 -> ""
    _ ->
      ", "
      <> string.join(
        int.range(from: 1, to: param_count + 1, with: [], run: fn(acc, n) {
          [
            case list.find(param_types, fn(pt) { pt.0 == n }) {
              Ok(#(_, col_name, _)) -> col_name <> ": " <> col_name
              Error(_) -> {
                let name = "p" <> int.to_string(n)
                name <> ": " <> name
              }
            },
            ..acc
          ]
        })
          |> list.reverse,
        ", ",
      )
  }

  // Strip comments and escape the SQL for Gleam string
  let escaped_sql = escape_string(strip_sql_comments(sql))
  let decoder_fn = case uses_model_decoder {
    True -> "decoder()"
    False -> snake_case(row_type_name) <> "_decoder()"
  }

  // Generate _wc (with connection) variant using native driver
  let wc_fn = case driver_type {
    "sqlite" ->
      generate_sqlite_wc_query(
        fn_name,
        row_type_name,
        escaped_sql,
        native_param_values,
        decoder_fn,
        param_list,
        is_single_row,
      )
    "postgres" ->
      generate_postgres_wc_query(
        fn_name,
        row_type_name,
        escaped_sql,
        param_types,
        param_count,
        decoder_fn,
        param_list,
        is_single_row,
      )
    _ ->
      generate_sqlite_wc_query(
        fn_name,
        row_type_name,
        escaped_sql,
        native_param_values,
        decoder_fn,
        param_list,
        is_single_row,
      )
  }

  // Generate main function that accepts Pool using get_connection
  let main_fn = case is_single_row {
    True ->
      "pub fn "
      <> fn_name
      <> "(pool pool: "
      <> driver_module
      <> ".Pool"
      <> param_list
      <> ") -> Result("
      <> row_type_name
      <> ", "
      <> driver_module
      <> ".DbError) {\n"
      <> "  use connection <- "
      <> driver_module
      <> ".get_connection(pool)\n"
      <> "  "
      <> fn_name
      <> "_wc(connection: connection"
      <> param_names
      <> ")\n}"
    False ->
      "pub fn "
      <> fn_name
      <> "(pool pool: "
      <> driver_module
      <> ".Pool"
      <> param_list
      <> ") -> Result(List("
      <> row_type_name
      <> "), "
      <> driver_module
      <> ".DbError) {\n"
      <> "  use connection <- "
      <> driver_module
      <> ".get_connection(pool)\n"
      <> "  "
      <> fn_name
      <> "_wc(connection: connection"
      <> param_names
      <> ")\n}"
  }

  string.join([main_fn, wc_fn], "\n\n")
}

/// Generates SQLite _wc query function using sqlight directly.
/// The _wc suffix indicates "with connection" for use within
/// transactions where a connection is already checked out.
///
fn generate_sqlite_wc_query(
  fn_name: String,
  row_type_name: String,
  escaped_sql: String,
  param_values: String,
  decoder_fn: String,
  param_list: String,
  is_single_row: Bool,
) -> String {
  case is_single_row {
    True ->
      "pub fn "
      <> fn_name
      <> "_wc(connection connection: pool.Connection"
      <> param_list
      <> ") -> Result("
      <> row_type_name
      <> ", pool.DbError) {\n"
      <> "  case sqlight.query(\""
      <> escaped_sql
      <> "\", connection, "
      <> param_values
      <> ", "
      <> decoder_fn
      <> ") {\n"
      <> "    Ok([row]) -> Ok(row)\n"
      <> "    Ok([]) -> Error(NotFound)\n"
      <> "    Ok(_) -> Error(QueryError(\"Expected single row\"))\n"
      <> "    Error(_) -> Error(QueryError(\"Query failed\"))\n"
      <> "  }\n}"
    False ->
      "pub fn "
      <> fn_name
      <> "_wc(connection connection: pool.Connection"
      <> param_list
      <> ") -> Result(List("
      <> row_type_name
      <> "), pool.DbError) {\n"
      <> "  case sqlight.query(\""
      <> escaped_sql
      <> "\", connection, "
      <> param_values
      <> ", "
      <> decoder_fn
      <> ") {\n"
      <> "    Ok(rows) -> Ok(rows)\n"
      <> "    Error(_) -> Error(QueryError(\"Query failed\"))\n"
      <> "  }\n}"
  }
}

/// Generates PostgreSQL _wc query function using pog directly.
/// The _wc suffix indicates "with connection" for use within
/// transactions where a connection is already checked out.
///
fn generate_postgres_wc_query(
  fn_name: String,
  row_type_name: String,
  escaped_sql: String,
  param_types: List(#(Int, String, ColumnType)),
  param_count: Int,
  decoder_fn: String,
  param_list: String,
  is_single_row: Bool,
) -> String {
  // Generate pog parameter chain
  let pog_params = case param_count {
    0 -> ""
    _ ->
      "\n"
      <> string.join(
        int.range(from: 1, to: param_count + 1, with: [], run: fn(acc, n) {
          [
            case list.find(param_types, fn(pt) { pt.0 == n }) {
              Ok(#(_, col_name, col_type)) -> {
                let wrapper = pog_wrapper(col_type)
                "    |> pog.parameter(" <> wrapper <> "(" <> col_name <> "))"
              }
              Error(_) ->
                "    |> pog.parameter(pog.text(p" <> int.to_string(n) <> "))"
            },
            ..acc
          ]
        })
          |> list.reverse,
        "\n",
      )
  }

  case is_single_row {
    True ->
      "pub fn "
      <> fn_name
      <> "_wc(connection connection: pool.Connection"
      <> param_list
      <> ") -> Result("
      <> row_type_name
      <> ", pool.DbError) {\n"
      <> "  let query = pog.query(\""
      <> escaped_sql
      <> "\")"
      <> pog_params
      <> "\n    |> pog.returning("
      <> decoder_fn
      <> ")\n"
      <> "  case pog.execute(query, connection) {\n"
      <> "    Ok(pog.Returned(_, [row])) -> Ok(row)\n"
      <> "    Ok(pog.Returned(_, [])) -> Error(NotFound)\n"
      <> "    Ok(_) -> Error(QueryError(\"Expected single row\"))\n"
      <> "    Error(_) -> Error(QueryError(\"Query failed\"))\n"
      <> "  }\n}"
    False ->
      "pub fn "
      <> fn_name
      <> "_wc(connection connection: pool.Connection"
      <> param_list
      <> ") -> Result(List("
      <> row_type_name
      <> "), pool.DbError) {\n"
      <> "  let query = pog.query(\""
      <> escaped_sql
      <> "\")"
      <> pog_params
      <> "\n    |> pog.returning("
      <> decoder_fn
      <> ")\n"
      <> "  case pog.execute(query, connection) {\n"
      <> "    Ok(pog.Returned(_, rows)) -> Ok(rows)\n"
      <> "    Error(_) -> Error(QueryError(\"Query failed\"))\n"
      <> "  }\n}"
  }
}

/// Generates two execute-style functions for queries without
/// SELECT columns (INSERT, UPDATE, DELETE). The main function
/// accepts Pool using get_connection, the _wc variant accepts
/// Connection for use in transactions. Returns Result with the
/// affected row count.
///
fn generate_execute_function(
  fn_name: String,
  sql: String,
  params: List(Int),
  param_types: List(#(Int, String, ColumnType)),
  driver_type: String,
) -> String {
  let param_count = list.length(params)

  // Get driver module name
  let driver_module = driver_module_name(driver_type)

  // Generate parameter list with proper types and labeled names
  let param_list = case param_count {
    0 -> ""
    _ ->
      ", "
      <> string.join(
        int.range(from: 1, to: param_count + 1, with: [], run: fn(acc, n) {
          [
            case list.find(param_types, fn(pt) { pt.0 == n }) {
              Ok(#(_, col_name, col_type)) -> {
                let gleam_type = codegen.gleam_type(col_type)
                col_name <> " " <> col_name <> ": " <> gleam_type
              }
              Error(_) -> {
                let name = "p" <> int.to_string(n)
                name <> " " <> name <> ": String"
              }
            },
            ..acc
          ]
        })
          |> list.reverse,
        ", ",
      )
  }

  // Generate param names for passing to _wc function (with labels)
  let param_names = case param_count {
    0 -> ""
    _ ->
      ", "
      <> string.join(
        int.range(from: 1, to: param_count + 1, with: [], run: fn(acc, n) {
          [
            case list.find(param_types, fn(pt) { pt.0 == n }) {
              Ok(#(_, col_name, _)) -> col_name <> ": " <> col_name
              Error(_) -> {
                let name = "p" <> int.to_string(n)
                name <> ": " <> name
              }
            },
            ..acc
          ]
        })
          |> list.reverse,
        ", ",
      )
  }

  // Strip comments and escape the SQL for Gleam string
  let escaped_sql = escape_string(strip_sql_comments(sql))

  // Generate _wc (with connection) variant using native driver
  let wc_fn = case driver_type {
    "sqlite" ->
      generate_sqlite_wc_execute(
        fn_name,
        escaped_sql,
        param_types,
        param_count,
        param_list,
      )
    "postgres" ->
      generate_postgres_wc_execute(
        fn_name,
        escaped_sql,
        param_types,
        param_count,
        param_list,
      )
    _ ->
      generate_sqlite_wc_execute(
        fn_name,
        escaped_sql,
        param_types,
        param_count,
        param_list,
      )
  }

  // Generate main function that accepts Pool using get_connection
  let main_fn =
    "pub fn "
    <> fn_name
    <> "(pool pool: "
    <> driver_module
    <> ".Pool"
    <> param_list
    <> ") -> Result(Int, "
    <> driver_module
    <> ".DbError) {\n"
    <> "  use connection <- "
    <> driver_module
    <> ".get_connection(pool)\n"
    <> "  "
    <> fn_name
    <> "_wc(connection: connection"
    <> param_names
    <> ")\n}"

  string.join([main_fn, wc_fn], "\n\n")
}

/// Generates SQLite _wc execute function using sqlight directly
/// for INSERT/UPDATE/DELETE queries. Returns the count of
/// affected rows.
///
fn generate_sqlite_wc_execute(
  fn_name: String,
  escaped_sql: String,
  param_types: List(#(Int, String, ColumnType)),
  param_count: Int,
  param_list: String,
) -> String {
  // Generate native parameter values
  let native_param_values = case param_count {
    0 -> "[]"
    _ ->
      "["
      <> string.join(
        int.range(from: 1, to: param_count + 1, with: [], run: fn(acc, n) {
          [
            case list.find(param_types, fn(pt) { pt.0 == n }) {
              Ok(#(_, col_name, col_type)) -> {
                let wrapper = native_wrapper(col_type, "sqlite")
                wrapper <> "(" <> col_name <> ")"
              }
              Error(_) -> "sqlight.text(p" <> int.to_string(n) <> ")"
            },
            ..acc
          ]
        })
          |> list.reverse,
        ", ",
      )
      <> "]"
  }

  "pub fn "
  <> fn_name
  <> "_wc(connection connection: pool.Connection"
  <> param_list
  <> ") -> Result(Int, pool.DbError) {\n"
  <> "  case sqlight.query(\""
  <> escaped_sql
  <> "\", connection, "
  <> native_param_values
  <> ", decode.dynamic) {\n"
  <> "    Ok(rows) -> Ok(list.length(rows))\n"
  <> "    Error(_) -> Error(QueryError(\"Query failed\"))\n"
  <> "  }\n}"
}

/// Generates PostgreSQL _wc execute function using pog directly
/// for INSERT/UPDATE/DELETE queries. Returns the count of
/// affected rows.
///
fn generate_postgres_wc_execute(
  fn_name: String,
  escaped_sql: String,
  param_types: List(#(Int, String, ColumnType)),
  param_count: Int,
  param_list: String,
) -> String {
  // Generate pog parameter chain
  let pog_params = case param_count {
    0 -> ""
    _ ->
      "\n"
      <> string.join(
        int.range(from: 1, to: param_count + 1, with: [], run: fn(acc, n) {
          [
            case list.find(param_types, fn(pt) { pt.0 == n }) {
              Ok(#(_, col_name, col_type)) -> {
                let wrapper = pog_wrapper(col_type)
                "    |> pog.parameter(" <> wrapper <> "(" <> col_name <> "))"
              }
              Error(_) ->
                "    |> pog.parameter(pog.text(p" <> int.to_string(n) <> "))"
            },
            ..acc
          ]
        })
          |> list.reverse,
        "\n",
      )
  }

  "pub fn "
  <> fn_name
  <> "_wc(connection connection: pool.Connection"
  <> param_list
  <> ") -> Result(Int, pool.DbError) {\n"
  <> "  let query = pog.query(\""
  <> escaped_sql
  <> "\")"
  <> pog_params
  <> "\n"
  <> "  case pog.execute(query, connection) {\n"
  <> "    Ok(pog.Returned(count, _)) -> Ok(count)\n"
  <> "    Error(_) -> Error(QueryError(\"Query failed\"))\n"
  <> "  }\n}"
}

/// Returns the driver module name based on driver_type. Used
/// to generate the correct import path and type references
/// in generated code.
///
fn driver_module_name(driver_type: String) -> String {
  case driver_type {
    "sqlite" -> "pool"
    "postgres" -> "pool"
    _ -> "pool"
  }
}

/// Returns the native wrapper function for sqlight/pog based
/// on column type and driver. Delegates to driver-specific
/// wrapper functions.
///
fn native_wrapper(col_type: ColumnType, driver_type: String) -> String {
  case driver_type {
    "sqlite" -> sqlight_wrapper(col_type)
    "postgres" -> pog_wrapper(col_type)
    _ -> sqlight_wrapper(col_type)
  }
}

/// Returns the native string wrapper for the driver. Used as
/// a fallback when the column type cannot be determined from
/// the schema.
///
fn native_string_wrapper(driver_type: String) -> String {
  case driver_type {
    "sqlite" -> "sqlight.text"
    "postgres" -> "pog.text"
    _ -> "sqlight.text"
  }
}

/// Returns the sqlight wrapper function for a column type.
/// Maps schema column types to sqlight parameter constructor
/// functions.
///
fn sqlight_wrapper(col_type: ColumnType) -> String {
  case col_type {
    schema_parser.Id -> "sqlight.int"
    schema_parser.String -> "sqlight.text"
    schema_parser.Text -> "sqlight.text"
    schema_parser.Int -> "sqlight.int"
    schema_parser.BigInt -> "sqlight.int"
    schema_parser.Float -> "sqlight.float"
    schema_parser.Boolean -> "sqlight.bool"
    schema_parser.Timestamp -> "sqlight.text"
    schema_parser.UnixTimestamp -> "sqlight.int"
    schema_parser.Date -> "sqlight.text"
    schema_parser.Json -> "sqlight.text"
    schema_parser.Uuid -> "sqlight.text"
    schema_parser.Foreign(_) -> "sqlight.int"
  }
}

/// Returns the pog wrapper function for a column type. Maps
/// schema column types to pog parameter constructor functions
/// for PostgreSQL queries.
///
fn pog_wrapper(col_type: ColumnType) -> String {
  case col_type {
    schema_parser.Id -> "pog.int"
    schema_parser.String -> "pog.text"
    schema_parser.Text -> "pog.text"
    schema_parser.Int -> "pog.int"
    schema_parser.BigInt -> "pog.int"
    schema_parser.Float -> "pog.float"
    schema_parser.Boolean -> "pog.bool"
    schema_parser.Timestamp -> "pog.text"
    schema_parser.UnixTimestamp -> "pog.int"
    schema_parser.Date -> "pog.text"
    schema_parser.Json -> "pog.text"
    schema_parser.Uuid -> "pog.text"
    schema_parser.Foreign(_) -> "pog.int"
  }
}

/// Converts a snake_case string to PascalCase for type names.
/// Splits on underscores and capitalizes each segment before
/// joining them together.
///
fn pascal_case(s: String) -> String {
  s
  |> string.split("_")
  |> list.map(capitalize)
  |> string.join("")
}

/// Converts a PascalCase string to snake_case for function
/// names. Inserts underscores before uppercase letters that
/// follow lowercase letters.
///
fn snake_case(s: String) -> String {
  do_snake_case(string.to_graphemes(s), "", False)
}

/// Recursive helper for snake_case conversion. Tracks whether
/// the previous character was lowercase to decide when to
/// insert underscores.
///
fn do_snake_case(chars: List(String), acc: String, prev_lower: Bool) -> String {
  case chars {
    [] -> string.lowercase(acc)
    [c, ..rest] -> {
      let is_upper = c == string.uppercase(c) && c != string.lowercase(c)
      case is_upper && prev_lower {
        True -> do_snake_case(rest, acc <> "_" <> c, False)
        False -> do_snake_case(rest, acc <> c, !is_upper)
      }
    }
  }
}

/// Capitalizes the first character of a string, leaving the
/// rest unchanged. Used for building PascalCase type names
/// from snake_case segments.
///
fn capitalize(s: String) -> String {
  case string.pop_grapheme(s) {
    Ok(#(first, rest)) -> string.uppercase(first) <> rest
    Error(_) -> s
  }
}

/// Escapes a string for use in generated Gleam code. Handles
/// backslashes, double quotes, and newlines to produce valid
/// Gleam string literals.
///
fn escape_string(s: String) -> String {
  s
  |> string.replace("\\", "\\\\")
  |> string.replace("\"", "\\\"")
  |> string.replace("\n", " ")
}

/// Removes both block (/* */) and line (--) comments from SQL
/// and collapses multiple spaces into single spaces. Prepares
/// SQL for embedding in generated code.
///
fn strip_sql_comments(sql: String) -> String {
  sql
  |> strip_block_comments()
  |> strip_line_comments()
  |> collapse_whitespace()
}

/// Recursively removes /* */ block comments from SQL. Handles
/// nested removal by repeatedly finding and removing comment
/// blocks.
///
fn strip_block_comments(sql: String) -> String {
  case string.split_once(sql, "/*") {
    Error(_) -> sql
    Ok(#(before, after)) -> {
      case string.split_once(after, "*/") {
        Error(_) -> before
        Ok(#(_, rest)) -> strip_block_comments(before <> " " <> rest)
      }
    }
  }
}

/// Removes -- line comments from SQL by splitting each line
/// at the comment marker and keeping only the code portion
/// before the comment.
///
fn strip_line_comments(sql: String) -> String {
  sql
  |> string.split("\n")
  |> list.map(fn(line) {
    case string.split_once(line, "--") {
      Error(_) -> line
      Ok(#(before, _)) -> before
    }
  })
  |> string.join(" ")
}

/// Recursively replaces multiple consecutive spaces with single
/// spaces until no double-spaces remain. Trims leading and
/// trailing whitespace from the final result.
///
fn collapse_whitespace(sql: String) -> String {
  let collapsed = string.replace(sql, "  ", " ")
  case collapsed == sql {
    True -> string.trim(sql)
    False -> collapse_whitespace(collapsed)
  }
}
