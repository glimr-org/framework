//// Cache Table Migration Generator
////
//// The cache system needs a backing table that varies by
//// database driver — Postgres uses BIGINT for Unix timestamps
//// while SQLite only has INTEGER. Generating the migration
//// here instead of shipping a static SQL file lets us branch
//// on the driver at generation time and produce a file that
//// the standard migration runner can apply without
//// special-casing.

import gleam/string
import glimr/console/console
import glimr/db/db
import shellout
import simplifile

// ------------------------------------------------------------- Public Functions

/// Entry point for the CLI `gen cache_table` command. Producing
/// a timestamped file in the migrations directory means the
/// normal migration workflow picks it up automatically — no
/// manual SQL authoring or registration step required.
///
pub fn run(database: String, table: String, driver: db.Driver) -> Nil {
  let migrations_path = "src/data/" <> database <> "/_migrations"

  let _ = simplifile.create_directory_all(migrations_path)

  let timestamp = get_timestamp()
  let filename = timestamp <> "_create_cache_table.sql"
  let migration_path = migrations_path <> "/" <> filename

  let int_type = case driver {
    db.Postgres -> "BIGINT"
    db.Sqlite -> "INTEGER"
  }

  let sql = "-- Generated by Glimr

CREATE TABLE IF NOT EXISTS " <> table <> " (
    key TEXT PRIMARY KEY,
    value TEXT NOT NULL,
    expiration " <> int_type <> " NOT NULL
);

-- Index for faster expiration lookups
CREATE INDEX IF NOT EXISTS idx_" <> table <> "_expiration ON " <> table <> " (expiration);
"

  case simplifile.write(migration_path, sql) {
    Ok(_) -> {
      console.output()
      |> console.line_success("Generated: " <> migration_path)
      |> console.print()
    }
    Error(_) -> {
      console.output()
      |> console.line_error("Failed to write migration file")
      |> console.print()
    }
  }
}

// ------------------------------------------------------------- Private Functions

/// Shelling out to `date` avoids pulling in a Gleam datetime
/// library just for one format string. The fallback zeroed
/// timestamp ensures the file is still created if the command
/// fails — better a bad name than a silent no-op.
///
fn get_timestamp() -> String {
  case shellout.command("date", ["+%Y%m%d%H%M%S"], ".", []) {
    Ok(output) -> string.trim(output)
    Error(_) -> "00000000000000"
  }
}
