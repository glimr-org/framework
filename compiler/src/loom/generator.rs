//! Code Generator
//!
//! Transforms parsed template ASTs into executable Gleam code.
//! Generates functions that build HTML strings using the
//! runtime helpers for escaping, conditionals, and loops.
//!

use super::gleam_parser::ParsedViewFile;
use super::lexer::ComponentAttr;
use super::parser::{Node, Template};
use std::collections::{HashMap, HashSet};

// ------------------------------------------------------------- Public Types

/// Maps component names to their expected data fields.
/// Used during code generation to determine which props a
/// component expects and provide appropriate defaults.
///
pub type ComponentDataMap = HashMap<String, Vec<(String, String)>>;

/// Information about a component's slot usage. Tracks both
/// the default slot and any named slots the component defines
/// for content projection.
///
#[derive(Debug, Clone, Default)]
pub struct ComponentSlotInfo {
    /// Whether the component has a default (unnamed) slot.
    /// Default slots receive children not assigned to named
    /// slots.
    ///
    pub has_default_slot: bool,
    /// Names of all named slots in the component. Named slots
    /// allow specific content to be projected into designated
    /// areas of the component template.
    ///
    pub named_slots: Vec<String>,
}

/// Maps component names to their slot information. Used during
/// code generation to generate correct slot parameters and
/// provide empty defaults for unused slots.
///
pub type ComponentSlotMap = HashMap<String, ComponentSlotInfo>;

// ------------------------------------------------------------- Private Types

/// A slot definition: optional name and child nodes. None name
/// indicates the default slot, Some(name) indicates a named
/// slot with the given identifier.
///
type SlotDef = (Option<String>, Vec<Node>);

/// The result of code generation containing the complete
/// Gleam source code ready to be written to a file for
/// compilation by the Gleam compiler.
///
#[derive(Debug, Clone)]
pub struct GeneratedCode {
    /// The complete Gleam source code including module header,
    /// imports, and the html function implementation.
    ///
    pub code: String,
}

// ------------------------------------------------------------- Public Functions

/// Generates Gleam code from a parsed template. This is the
/// main entry point for code generation, coordinating module
/// creation with imports and html function generation.
///
pub fn generate(
    template: &Template,
    module_name: &str,
    is_component: bool,
    view_file: Option<&ParsedViewFile>,
    component_data: &ComponentDataMap,
    component_slots: &ComponentSlotMap,
) -> GeneratedCode {
    let code = generate_module(
        template,
        module_name,
        is_component,
        view_file,
        component_data,
        component_slots,
    );

    GeneratedCode { code }
}

/// Extracts complete slot information from a component template.
/// Analyzes the template AST to find both default and named
/// slots used in the component.
///
pub fn extract_slot_info(template: &Template) -> ComponentSlotInfo {
    ComponentSlotInfo {
        has_default_slot: has_default_slot(&template.nodes),
        named_slots: collect_named_slots(&template.nodes).into_iter().collect(),
    }
}

// ------------------------------------------------------------- Private Functions

/// Generates the complete Gleam module code including the
/// auto-generated header warning, imports section, and the
/// html function that renders the template.
///
fn generate_module(
    template: &Template,
    _module_name: &str,
    is_component: bool,
    view_file: Option<&ParsedViewFile>,
    component_data: &ComponentDataMap,
    component_slots: &ComponentSlotMap,
) -> String {
    let header = r#"//// This file was generated by Glimr âœ¨
//// https://github.com/glimr-org/glimr?tab=readme-ov-file#loom
////
//// DO NOT EDIT THIS FILE DIRECTLY. Instead, edit the corresponding
//// .loom.html template file and run `./glimr loom:compile`.
////
"#;

    let imports = generate_imports(template, view_file);
    let html_fn = generate_html_function(
        template,
        is_component,
        view_file,
        component_data,
        component_slots,
    );

    format!("{}\n{}\n\n{}", header, imports, html_fn)
}

/// Generates the import statements for the module. Includes the
/// runtime import, user imports from the view file, and imports
/// for any component dependencies discovered in the template.
///
fn generate_imports(template: &Template, view_file: Option<&ParsedViewFile>) -> String {
    let mut imports = vec!["import glimr/loom/runtime".to_string()];

    // Copy user imports (filter out compiled/ imports)
    if let Some(vf) = view_file {
        for imp in &vf.imports {
            if !imp.contains("compiled/") {
                imports.push(imp.clone());
            }
        }
    }

    // Collect component names
    let component_names = collect_component_names(&template.nodes);
    let mut sorted_names: Vec<_> = component_names.into_iter().collect();
    sorted_names.sort();

    for name in sorted_names {
        let module_path = format!("compiled/loom/components/{}", name.replace(':', "/"));
        let alias = component_module_alias(&name);
        imports.push(format!("import {} as {}", module_path, alias));
    }

    imports.join("\n")
}

/// Recursively collects all component names used in the template
/// AST. Traverses into conditionals, loops, and nested elements
/// to find all component references.
///
fn collect_component_names(nodes: &[Node]) -> HashSet<String> {
    let mut names = HashSet::new();

    for node in nodes {
        match node {
            Node::Component { name, children, .. } => {
                names.insert(name.clone());
                names.extend(collect_component_names(children));
            }
            Node::If { branches } => {
                for (_, body) in branches {
                    names.extend(collect_component_names(body));
                }
            }
            Node::Each { body, .. } => {
                names.extend(collect_component_names(body));
            }
            Node::SlotDef { children, .. } => {
                names.extend(collect_component_names(children));
            }
            Node::Element { children, .. } => {
                names.extend(collect_component_names(children));
            }
            _ => {}
        }
    }

    names
}

/// Recursively collects all named slot identifiers from the
/// template AST. Used to determine which slot parameters the
/// html function needs to accept.
///
fn collect_named_slots(nodes: &[Node]) -> HashSet<String> {
    let mut slots = HashSet::new();

    for node in nodes {
        match node {
            Node::Slot {
                name: Some(n),
                fallback,
            } => {
                slots.insert(n.clone());
                slots.extend(collect_named_slots(fallback));
            }
            Node::Slot {
                name: None,
                fallback,
            } => {
                slots.extend(collect_named_slots(fallback));
            }
            Node::If { branches } => {
                for (_, body) in branches {
                    slots.extend(collect_named_slots(body));
                }
            }
            Node::Each { body, .. } => {
                slots.extend(collect_named_slots(body));
            }
            Node::Component { children, .. } => {
                slots.extend(collect_named_slots(children));
            }
            Node::SlotDef { children, .. } => {
                slots.extend(collect_named_slots(children));
            }
            Node::Element { children, .. } => {
                slots.extend(collect_named_slots(children));
            }
            _ => {}
        }
    }

    slots
}

/// Generates the pub fn html(...) function that renders the
/// template. Handles attribute injection for components and
/// builds the function signature from view file data.
///
fn generate_html_function(
    template: &Template,
    is_component: bool,
    view_file: Option<&ParsedViewFile>,
    component_data: &ComponentDataMap,
    component_slots: &ComponentSlotMap,
) -> String {
    // For components, inject @attributes into first element if not present
    let nodes = if is_component && !has_attributes_node(&template.nodes) {
        inject_attributes_into_first_element(&template.nodes)
    } else {
        template.nodes.clone()
    };

    let params = generate_function_params(template, is_component, view_file);
    let body = generate_nodes_code(&nodes, 1, component_data, component_slots);

    format!("pub fn html({}) -> String {{\n  \"\"\n{}}}\n", params, body)
}

/// Generates the parameter list for the html function. Includes
/// data fields from the view file, slot parameters, and the
/// attributes parameter for components.
///
fn generate_function_params(
    template: &Template,
    is_component: bool,
    view_file: Option<&ParsedViewFile>,
) -> String {
    let mut params = Vec::new();

    // Data fields from parsed view file
    if let Some(vf) = view_file {
        for (name, type_str) in &vf.fields {
            params.push(format!("{} {}: {}", name, name, type_str));
        }
    }

    // Slot parameters
    if has_default_slot(&template.nodes) {
        params.push("slot slot: String".to_string());
    }

    let named_slots = collect_named_slots(&template.nodes);
    let mut sorted_slots: Vec<_> = named_slots.into_iter().collect();
    sorted_slots.sort();
    for name in sorted_slots {
        let field = to_field_name(&name);
        params.push(format!("slot_{} slot_{}: String", field, field));
    }

    // Attributes parameter for components
    if is_component {
        params.push("attributes attributes: List(runtime.Attribute)".to_string());
    }

    params.join(", ")
}

/// Checks if any node in the template contains an unnamed slot.
/// Recursively searches through conditionals, loops, and nested
/// structures to find default slot usage.
///
fn has_default_slot(nodes: &[Node]) -> bool {
    nodes.iter().any(|node| match node {
        Node::Slot { name: None, .. } => true,
        Node::Slot {
            name: Some(_),
            fallback,
        } => has_default_slot(fallback),
        Node::If { branches } => branches.iter().any(|(_, body)| has_default_slot(body)),
        Node::Each { body, .. } => has_default_slot(body),
        Node::Component { children, .. } => has_default_slot(children),
        Node::SlotDef { children, .. } => has_default_slot(children),
        Node::Element { children, .. } => has_default_slot(children),
        _ => false,
    })
}

/// Generates Gleam code for a sequence of template nodes.
/// Iterates through nodes and concatenates their generated
/// code output.
///
fn generate_nodes_code(
    nodes: &[Node],
    indent: usize,
    component_data: &ComponentDataMap,
    component_slots: &ComponentSlotMap,
) -> String {
    nodes
        .iter()
        .map(|node| generate_node_code(node, indent, component_data, component_slots))
        .collect::<Vec<_>>()
        .join("")
}

/// Generates Gleam code for a single template node. Handles all
/// node types including text, variables, slots, conditionals,
/// loops, components, and elements.
///
fn generate_node_code(
    node: &Node,
    indent: usize,
    component_data: &ComponentDataMap,
    component_slots: &ComponentSlotMap,
) -> String {
    let pad = "  ".repeat(indent);

    match node {
        Node::Text(text) => {
            let escaped = escape_gleam_string(text);
            format!("{}<> \"{}\"\n", pad, escaped)
        }

        Node::Variable(expr) => {
            format!("{}<> runtime.escape({})\n", pad, expr)
        }

        Node::RawVariable(expr) => {
            format!("{}<> {}\n", pad, expr)
        }

        Node::Slot {
            name: None,
            fallback,
        } if fallback.is_empty() => {
            format!("{}<> slot\n", pad)
        }

        Node::Slot {
            name: None,
            fallback,
        } => {
            let fallback_code =
                generate_nodes_code(fallback, indent + 1, component_data, component_slots);
            format!(
                "{}|> runtime.append_if(slot == \"\", fn(acc) {{\n{}  acc\n{}{}}})\n{}|> runtime.append_if(slot != \"\", fn(acc) {{ acc <> slot }})\n",
                pad, pad, fallback_code, pad, pad
            )
        }

        Node::Slot {
            name: Some(name),
            fallback,
        } if fallback.is_empty() => {
            format!("{}<> slot_{}\n", pad, to_field_name(name))
        }

        Node::Slot {
            name: Some(name),
            fallback,
        } => {
            let slot_var = format!("slot_{}", to_field_name(name));
            let fallback_code =
                generate_nodes_code(fallback, indent + 1, component_data, component_slots);
            format!(
                "{}|> runtime.append_if({} == \"\", fn(acc) {{\n{}  acc\n{}{}}})\n{}|> runtime.append_if({} != \"\", fn(acc) {{ acc <> {} }})\n",
                pad, slot_var, pad, fallback_code, pad, pad, slot_var, slot_var
            )
        }

        Node::SlotDef { .. } => {
            // SlotDefNodes are handled separately
            String::new()
        }

        Node::If { branches } => {
            let mut branches_code = String::new();
            let mut has_else = false;

            for (condition, body) in branches {
                let body_code =
                    generate_nodes_code(body, indent + 4, component_data, component_slots);

                if let Some(cond) = condition {
                    let transformed = transform_slot_condition(cond);
                    branches_code.push_str(&format!(
                        "{}    _ if {} -> {{\n{}      \"\"\n{}{}}}\n",
                        pad, transformed, pad, body_code, pad
                    ));
                } else {
                    has_else = true;
                    branches_code.push_str(&format!(
                        "{}    _ -> {{\n{}      \"\"\n{}{}}}\n",
                        pad, pad, body_code, pad
                    ));
                }
            }

            if !has_else {
                branches_code.push_str(&format!("{}    _ -> \"\"\n", pad));
            }

            format!("{}<> case Nil {{\n{}{}  }}\n", pad, branches_code, pad)
        }

        Node::Each {
            collection,
            items,
            loop_var,
            body,
        } => {
            let body_code = generate_nodes_code(body, indent + 2, component_data, component_slots);
            let items_pattern = format_each_items_pattern(items);

            if let Some(loop_name) = loop_var {
                format!(
                    "{}|> runtime.append_each_with_loop({}, fn(acc, {}, {}) {{\n{}  acc\n{}{}}})\\n",
                    pad, collection, items_pattern, loop_name, pad, body_code, pad
                )
            } else {
                format!(
                    "{}|> runtime.append_each({}, fn(acc, {}) {{\n{}  acc\n{}{}}})\\n",
                    pad, collection, items_pattern, pad, body_code, pad
                )
            }
        }

        Node::Component {
            name,
            attributes,
            children,
        } => {
            let module_alias = component_module_alias(name);
            let (default_children, named_slots) = separate_slot_defs(children);
            let (props_code, extra_attrs_code) =
                generate_component_attrs(name, attributes, indent + 2, component_data);
            let named_slots_code = generate_component_named_slots(
                name,
                &named_slots,
                indent + 2,
                component_data,
                component_slots,
            );

            // Check if the component has a default slot
            let component_has_slot = component_slots
                .get(name)
                .map(|info| info.has_default_slot)
                .unwrap_or(true);

            let slot_code = if component_has_slot {
                let default_slot_code = generate_nodes_code(
                    &default_children,
                    indent + 2,
                    component_data,
                    component_slots,
                );
                format!(
                    "{}    slot: {{\n{}      \"\"\n{}{}}},\n",
                    pad, pad, default_slot_code, pad
                )
            } else {
                String::new()
            };

            format!(
                "{}<> {}.html(\n{}{}{}\
                {}    attributes: {},\n\
                {}  )\n",
                pad,
                module_alias,
                props_code,
                named_slots_code,
                slot_code,
                pad,
                extra_attrs_code,
                pad
            )
        }

        Node::Attributes(base_attrs) => {
            if base_attrs.is_empty() {
                format!("{}<> \" \" <> runtime.render_attributes(attributes)\n", pad)
            } else {
                let base_attrs_code = generate_base_attrs_code(base_attrs);
                format!(
                    "{}<> \" \" <> runtime.render_attributes(runtime.merge_attributes({}, attributes))\n",
                    pad, base_attrs_code
                )
            }
        }

        Node::Element {
            tag,
            attributes,
            children,
        } => {
            let attrs_code = generate_element_attrs_code(attributes);
            let children_code =
                generate_nodes_code(children, indent, component_data, component_slots);

            if is_void_element(tag) {
                format!("{}<> \"<{}\"\n{}{}<> \" />\"\n", pad, tag, attrs_code, pad)
            } else {
                format!(
                    "{}<> \"<{}\"\n{}{}<> \">\"\n{}{}<> \"</{}>\"\n",
                    pad, tag, attrs_code, pad, children_code, pad, tag
                )
            }
        }
    }
}

/// Separates component children into default content and named
/// slot definitions. Returns a tuple of nodes for the default
/// slot and a list of named slot definitions.
///
fn separate_slot_defs(nodes: &[Node]) -> (Vec<Node>, Vec<SlotDef>) {
    let mut default_nodes = Vec::new();
    let mut slot_defs = Vec::new();

    for node in nodes {
        match node {
            Node::SlotDef { name, children } => {
                slot_defs.push((name.clone(), children.clone()));
            }
            _ => default_nodes.push(node.clone()),
        }
    }

    (default_nodes, slot_defs)
}

/// Transforms slot-based conditions from template syntax to
/// Gleam code. Converts "slot" to slot != "" and "slot.name"
/// to slot_name != "" for conditional rendering.
///
fn transform_slot_condition(condition: &str) -> String {
    let trimmed = condition.trim();
    if trimmed == "slot" {
        "slot != \"\"".to_string()
    } else if let Some(name) = trimmed.strip_prefix("slot.") {
        format!("slot_{} != \"\"", to_field_name(name))
    } else {
        condition.to_string()
    }
}

/// Generates prop assignments and extra attributes for a
/// component call. Separates known props from passthrough
/// attributes and provides defaults for unspecified props.
///
fn generate_component_attrs(
    component_name: &str,
    attributes: &[ComponentAttr],
    indent: usize,
    component_data: &ComponentDataMap,
) -> (String, String) {
    let pad = "  ".repeat(indent);

    let expected_prop_names: HashSet<String> = component_data
        .get(component_name)
        .map(|props| props.iter().map(|(n, _)| n.clone()).collect())
        .unwrap_or_default();

    // Get explicitly provided props
    let explicit_props: HashSet<String> = attributes
        .iter()
        .filter_map(|attr| match attr {
            ComponentAttr::ExprAttr { name, .. } => {
                let field = to_field_name(name);
                if expected_prop_names.contains(&field) {
                    Some(field)
                } else {
                    None
                }
            }
            ComponentAttr::BoolAttr(name) => {
                let field = to_field_name(name);
                if expected_prop_names.contains(&field) {
                    Some(field)
                } else {
                    None
                }
            }
            _ => None,
        })
        .collect();

    // Generate explicit props code
    let explicit_props_code: String = attributes
        .iter()
        .filter_map(|attr| match attr {
            ComponentAttr::ExprAttr { name, value } => {
                let field = to_field_name(name);
                if expected_prop_names.contains(&field) {
                    Some(format!("{}{}: {},\n", pad, field, value))
                } else {
                    None
                }
            }
            ComponentAttr::BoolAttr(name) => {
                let field = to_field_name(name);
                if expected_prop_names.contains(&field) {
                    Some(format!("{}{}: True,\n", pad, field))
                } else {
                    None
                }
            }
            _ => None,
        })
        .collect();

    // Generate default props code
    let default_props_code: String = component_data
        .get(component_name)
        .map(|expected| {
            expected
                .iter()
                .filter_map(|(prop_name, prop_type)| {
                    if explicit_props.contains(prop_name) {
                        None
                    } else {
                        let default = default_for_type(prop_type);
                        Some(format!("{}{}: {},\n", pad, prop_name, default))
                    }
                })
                .collect()
        })
        .unwrap_or_default();

    let props_code = format!("{}{}", explicit_props_code, default_props_code);

    // Generate attributes list
    let attrs_items: Vec<String> = attributes
        .iter()
        .filter_map(|attr| {
            match attr {
                ComponentAttr::StringAttr { name, value } => Some(format!(
                    "runtime.Attribute(\"{}\", \"{}\")",
                    name,
                    escape_gleam_string(value)
                )),
                ComponentAttr::ExprAttr { name, value } => {
                    let field = to_field_name(name);
                    if expected_prop_names.contains(&field) {
                        None // It's a prop
                    } else if is_html_boolean_attribute(name) {
                        Some(format!("runtime.BoolAttribute(\"{}\", {})", name, value))
                    } else {
                        Some(format!("runtime.Attribute(\"{}\", {})", name, value))
                    }
                }
                ComponentAttr::BoolAttr(name) => {
                    let field = to_field_name(name);
                    if expected_prop_names.contains(&field) {
                        None
                    } else {
                        Some(format!("runtime.Attribute(\"{}\", \"{}\")", name, name))
                    }
                }
                ComponentAttr::ClassAttr(value) => Some(format!(
                    "runtime.Attribute(\"class\", runtime.build_classes({}))",
                    transform_class_list(value)
                )),
                ComponentAttr::StyleAttr(value) => Some(format!(
                    "runtime.Attribute(\"style\", runtime.build_styles({}))",
                    transform_style_list(value)
                )),
                ComponentAttr::LmIf(_)
                | ComponentAttr::LmElseIf(_)
                | ComponentAttr::LmElse
                | ComponentAttr::LmFor { .. } => None,
            }
        })
        .collect();

    let extra_attrs_code = if attrs_items.is_empty() {
        "[]".to_string()
    } else {
        format!("[{}]", attrs_items.join(", "))
    };

    (props_code, extra_attrs_code)
}

/// Returns the default value for a Gleam type. Used to provide
/// sensible defaults for component props that aren't explicitly
/// passed when rendering a component.
///
fn default_for_type(type_str: &str) -> &'static str {
    match type_str {
        "Bool" => "False",
        "String" => "\"\"",
        "Int" => "0",
        "Float" => "0.0",
        _ if type_str.starts_with("Option(") => "None",
        _ if type_str.starts_with("List(") => "[]",
        _ => "todo",
    }
}

/// Checks if an HTML attribute is a boolean attribute. Boolean
/// attributes are rendered differently, only appearing when
/// true and omitted entirely when false.
///
fn is_html_boolean_attribute(name: &str) -> bool {
    matches!(
        name,
        "disabled"
            | "checked"
            | "readonly"
            | "required"
            | "hidden"
            | "selected"
            | "multiple"
            | "autofocus"
            | "autoplay"
            | "controls"
            | "loop"
            | "muted"
            | "default"
            | "defer"
            | "async"
            | "novalidate"
            | "formnovalidate"
            | "ismap"
            | "nomodule"
            | "playsinline"
            | "open"
            | "reversed"
            | "allowfullscreen"
            | "inert"
            | "itemscope"
    )
}

/// Generates named slot arguments for a component call. Creates
/// slot content for provided slots and empty strings for
/// expected but unprovided named slots.
///
fn generate_component_named_slots(
    component_name: &str,
    named_slots: &[(Option<String>, Vec<Node>)],
    indent: usize,
    component_data: &ComponentDataMap,
    component_slots: &ComponentSlotMap,
) -> String {
    let pad = "  ".repeat(indent);

    // Filter to only named slots
    let actual_named_slots: Vec<(&String, &Vec<Node>)> = named_slots
        .iter()
        .filter_map(|(name, children)| name.as_ref().map(|n| (n, children)))
        .collect();

    let provided_slot_names: HashSet<&String> =
        actual_named_slots.iter().map(|(n, _)| *n).collect();

    let expected_slots = component_slots
        .get(component_name)
        .map(|info| &info.named_slots)
        .cloned()
        .unwrap_or_default();

    let mut code = String::new();

    // Generate provided slots
    for (name, children) in actual_named_slots {
        let slot_code = generate_nodes_code(children, indent + 2, component_data, component_slots);
        code.push_str(&format!(
            "{}slot_{}: {{\n{}  \"\"\n{}{}}},\n",
            pad,
            to_field_name(name),
            pad,
            slot_code,
            pad
        ));
    }

    // Generate empty strings for missing slots
    for name in expected_slots {
        if !provided_slot_names.contains(&name) {
            code.push_str(&format!("{}slot_{}: \"\",\n", pad, to_field_name(&name)));
        }
    }

    code
}

/// Generates the attribute rendering code for a regular HTML
/// element. Returns a code fragment that renders attributes
/// using the runtime helper.
///
fn generate_element_attrs_code(attrs: &[ComponentAttr]) -> String {
    if attrs.is_empty() {
        return String::new();
    }

    let items: Vec<String> = attrs
        .iter()
        .filter_map(|attr| match attr {
            ComponentAttr::StringAttr { name, value } => Some(format!(
                "runtime.Attribute(\"{}\", \"{}\")",
                name,
                escape_gleam_string(value)
            )),
            ComponentAttr::ExprAttr { name, value } => {
                if is_html_boolean_attribute(name) {
                    Some(format!("runtime.BoolAttribute(\"{}\", {})", name, value))
                } else {
                    Some(format!("runtime.Attribute(\"{}\", {})", name, value))
                }
            }
            ComponentAttr::BoolAttr(name) => {
                Some(format!("runtime.Attribute(\"{}\", \"{}\")", name, name))
            }
            ComponentAttr::ClassAttr(value) => Some(format!(
                "runtime.Attribute(\"class\", runtime.build_classes({}))",
                transform_class_list(value)
            )),
            ComponentAttr::StyleAttr(value) => Some(format!(
                "runtime.Attribute(\"style\", runtime.build_styles({}))",
                transform_style_list(value)
            )),
            ComponentAttr::LmIf(_)
            | ComponentAttr::LmElseIf(_)
            | ComponentAttr::LmElse
            | ComponentAttr::LmFor { .. } => None,
        })
        .collect();

    if items.is_empty() {
        String::new()
    } else {
        format!(
            "  <> \" \" <> runtime.render_attributes([{}])\n",
            items.join(", ")
        )
    }
}

/// Checks if an HTML tag is a void element. Void elements are
/// self-closing and cannot have children, so they're rendered
/// with /> instead of a closing tag.
///
fn is_void_element(tag: &str) -> bool {
    matches!(
        tag,
        "area"
            | "base"
            | "br"
            | "col"
            | "embed"
            | "hr"
            | "img"
            | "input"
            | "link"
            | "meta"
            | "param"
            | "source"
            | "track"
            | "wbr"
    )
}

/// Generates a list literal of base attributes for @attributes
/// merging. These are the component's own attributes that get
/// merged with passed-through attributes.
///
fn generate_base_attrs_code(attrs: &[ComponentAttr]) -> String {
    let items: Vec<String> = attrs
        .iter()
        .filter_map(|attr| match attr {
            ComponentAttr::StringAttr { name, value } => Some(format!(
                "runtime.Attribute(\"{}\", \"{}\")",
                name,
                escape_gleam_string(value)
            )),
            ComponentAttr::BoolAttr(name) => {
                Some(format!("runtime.Attribute(\"{}\", \"{}\")", name, name))
            }
            ComponentAttr::ExprAttr { name, value } => {
                Some(format!("runtime.Attribute(\"{}\", {})", name, value))
            }
            ComponentAttr::ClassAttr(value) => Some(format!(
                "runtime.Attribute(\"class\", runtime.build_classes({}))",
                transform_class_list(value)
            )),
            ComponentAttr::StyleAttr(value) => Some(format!(
                "runtime.Attribute(\"style\", runtime.build_styles({}))",
                transform_style_list(value)
            )),
            ComponentAttr::LmIf(_)
            | ComponentAttr::LmElseIf(_)
            | ComponentAttr::LmElse
            | ComponentAttr::LmFor { .. } => None,
        })
        .collect();

    format!("[{}]", items.join(", "))
}

/// Checks if any node in the template contains an @attributes
/// directive. Used to determine if automatic attribute injection
/// is needed for components.
///
fn has_attributes_node(nodes: &[Node]) -> bool {
    nodes.iter().any(|node| match node {
        Node::Attributes(_) => true,
        Node::If { branches } => branches.iter().any(|(_, body)| has_attributes_node(body)),
        Node::Each { body, .. } => has_attributes_node(body),
        Node::SlotDef { children, .. } => has_attributes_node(children),
        Node::Component { children, .. } => has_attributes_node(children),
        Node::Element { children, .. } => has_attributes_node(children),
        _ => false,
    })
}

/// Injects @attributes into the first HTML element of a
/// component template. Enables attribute pass-through without
/// explicit @attributes in the template.
///
fn inject_attributes_into_first_element(nodes: &[Node]) -> Vec<Node> {
    inject_attributes_helper(nodes, false).0
}

/// Helper for attribute injection that tracks injection state.
/// Returns modified nodes and whether injection occurred to
/// prevent multiple injections.
///
fn inject_attributes_helper(nodes: &[Node], injected: bool) -> (Vec<Node>, bool) {
    if injected {
        return (nodes.to_vec(), true);
    }

    let mut result = Vec::new();
    let mut did_inject = false;

    for node in nodes {
        if did_inject {
            result.push(node.clone());
            continue;
        }

        match node {
            Node::Text(text) => {
                if let Some((before, attrs, after)) = find_first_tag_and_extract_attrs(text) {
                    result.push(Node::Text(before));
                    result.push(Node::Attributes(attrs));
                    result.push(Node::Text(after));
                    did_inject = true;
                } else {
                    result.push(node.clone());
                }
            }
            Node::Element {
                tag,
                attributes,
                children,
            } => {
                result.push(Node::Element {
                    tag: tag.clone(),
                    attributes: vec![],
                    children: {
                        let mut new_children = vec![Node::Attributes(attributes.clone())];
                        new_children.extend(children.clone());
                        new_children
                    },
                });
                did_inject = true;
            }
            Node::If { branches } => {
                let mut new_branches = Vec::new();
                for (cond, body) in branches {
                    let (new_body, injected_in_branch) = inject_attributes_helper(body, did_inject);
                    new_branches.push((cond.clone(), new_body));
                    did_inject = did_inject || injected_in_branch;
                }
                result.push(Node::If {
                    branches: new_branches,
                });
            }
            Node::Each {
                collection,
                items,
                loop_var,
                body,
            } => {
                let (new_body, injected_in_loop) = inject_attributes_helper(body, did_inject);
                result.push(Node::Each {
                    collection: collection.clone(),
                    items: items.clone(),
                    loop_var: loop_var.clone(),
                    body: new_body,
                });
                did_inject = did_inject || injected_in_loop;
            }
            _ => result.push(node.clone()),
        }
    }

    (result, did_inject)
}

/// Finds the first HTML tag in a text node and extracts its
/// attributes. Used for injecting @attributes into raw HTML
/// text within templates.
///
fn find_first_tag_and_extract_attrs(text: &str) -> Option<(String, Vec<ComponentAttr>, String)> {
    let (before, after_open) = text.split_once('<')?;
    let (tag_name, attrs, closing) = parse_tag_content(after_open)?;
    Some((format!("{}<{} ", before, tag_name), attrs, closing))
}

/// Parses the content after an opening angle bracket to extract
/// tag name, attributes, and remaining content. Returns None for
/// closing tags and comments.
///
fn parse_tag_content(content: &str) -> Option<(String, Vec<ComponentAttr>, String)> {
    let content = content.trim_start();
    let (tag_name, rest) = take_until_space_or_close(content);

    if tag_name.is_empty() || tag_name.starts_with('/') || tag_name.starts_with('!') {
        return None;
    }

    let (attrs, closing) = parse_html_attributes(rest.trim_start());
    Some((tag_name, attrs, closing))
}

/// Extracts text until whitespace or tag closing character.
/// Used to parse tag names and attribute names from HTML
/// content.
///
fn take_until_space_or_close(input: &str) -> (String, String) {
    let mut end = 0;
    for c in input.chars() {
        match c {
            ' ' | '\t' | '\n' | '\r' | '>' | '/' | '=' => break,
            _ => end += c.len_utf8(),
        }
    }
    (input[..end].to_string(), input[end..].to_string())
}

/// Parses HTML attributes from a string until a tag closing
/// character is found. Returns the parsed attributes and any
/// remaining content after the attributes.
///
fn parse_html_attributes(input: &str) -> (Vec<ComponentAttr>, String) {
    let mut attrs = Vec::new();
    let mut current = input.trim_start().to_string();

    loop {
        if current.is_empty() {
            return (attrs, String::new());
        }

        if current.starts_with('>') {
            return (attrs, current);
        }

        if current.starts_with("/>") {
            return (attrs, current);
        }

        if let Some((attr, remaining)) = parse_single_html_attribute(&current) {
            attrs.push(attr);
            current = remaining.trim_start().to_string();
        } else if let Some(c) = current.chars().next() {
            // Skip unknown character
            current = current[c.len_utf8()..].to_string();
        }
    }
}

/// Parses a single HTML attribute from input. Handles quoted
/// values, unquoted values, and boolean attributes that have
/// no value.
///
fn parse_single_html_attribute(input: &str) -> Option<(ComponentAttr, String)> {
    let input = input.trim_start();
    let (name, rest) = take_until_space_or_close(input);

    if name.is_empty() {
        return None;
    }

    let rest = rest.trim_start();

    if let Some(after_eq) = rest.strip_prefix('=') {
        let after_eq = after_eq.trim_start();

        if let Some(after_quote) = after_eq.strip_prefix('"')
            && let Some(end) = after_quote.find('"')
        {
            let value = after_quote[..end].to_string();
            let remaining = after_quote[end + 1..].to_string();
            return Some((ComponentAttr::StringAttr { name, value }, remaining));
        }

        if let Some(after_quote) = after_eq.strip_prefix('\'')
            && let Some(end) = after_quote.find('\'')
        {
            let value = after_quote[..end].to_string();
            let remaining = after_quote[end + 1..].to_string();
            return Some((ComponentAttr::StringAttr { name, value }, remaining));
        }

        let (value, remaining) = take_until_space_or_close(after_eq);
        return Some((ComponentAttr::StringAttr { name, value }, remaining));
    }

    Some((ComponentAttr::BoolAttr(name), rest.to_string()))
}

/// Converts an attribute or slot name to a valid Gleam field
/// name. Replaces hyphens, colons, and spaces with underscores
/// and converts to snake_case.
///
fn to_field_name(name: &str) -> String {
    let replaced = name.replace(['-', ':', ' '], "_");
    to_snake_case(&replaced)
}

/// Converts a string to snake_case by inserting underscores
/// before uppercase letters and lowercasing. Handles leading
/// underscores by trimming them.
///
fn to_snake_case(input: &str) -> String {
    let mut result = String::new();
    for c in input.chars() {
        if c.is_uppercase() {
            if !result.is_empty() {
                result.push('_');
            }
            result.push(c.to_ascii_lowercase());
        } else {
            result.push(c);
        }
    }
    result.trim_start_matches('_').to_string()
}

/// Escapes a string for inclusion in Gleam string literals.
/// Handles backslashes, quotes, and common whitespace escape
/// sequences.
///
fn escape_gleam_string(input: &str) -> String {
    input
        .replace('\\', "\\\\")
        .replace('"', "\\\"")
        .replace('\n', "\\n")
        .replace('\r', "\\r")
        .replace('\t', "\\t")
}

/// Generates the import alias for a component module. Prefixes
/// with "components_" and replaces colons and hyphens to create
/// valid Gleam identifiers.
///
fn component_module_alias(name: &str) -> String {
    format!("components_{}", name.replace([':', '-'], "_"))
}

/// Formats the pattern for @each loop variables. Single items
/// use the variable directly, multiple items are wrapped in a
/// tuple pattern.
///
fn format_each_items_pattern(items: &[String]) -> String {
    if items.len() == 1 {
        items[0].clone()
    } else {
        format!("#({})", items.join(", "))
    }
}

/// Transforms a class list expression by wrapping string
/// literals with runtime.class(). Preserves expressions and
/// handles nested structures.
///
fn transform_class_list(value: &str) -> String {
    transform_list_strings(value, "runtime.class")
}

/// Transforms a style list expression by wrapping string
/// literals with runtime.style(). Preserves expressions and
/// handles nested structures.
///
fn transform_style_list(value: &str) -> String {
    transform_list_strings(value, "runtime.style")
}

/// Transforms a list expression by wrapping string literals
/// with the specified wrapper function. Tracks nesting depth
/// to correctly identify top-level list elements.
///
fn transform_list_strings(value: &str, wrapper: &str) -> String {
    let mut result = String::new();
    let mut current = String::new();
    let mut depth = 0;
    let mut in_string = false;
    let mut chars = value.chars().peekable();

    while let Some(c) = chars.next() {
        if in_string {
            if c == '\\' && chars.peek().is_some() {
                current.push(c);
                current.push(chars.next().unwrap());
                continue;
            }
            if c == '"' {
                current.push(c);
                in_string = false;
                continue;
            }
            current.push(c);
        } else {
            match c {
                '"' => {
                    if depth == 1 {
                        current.push_str(wrapper);
                        current.push('(');
                    }
                    current.push(c);
                    in_string = true;
                }
                '[' => {
                    depth += 1;
                    current.push(c);
                }
                ']' => {
                    if depth == 1 && current.contains(&format!("{}(", wrapper)) {
                        current.push(')');
                    }
                    current.push(c);
                    depth -= 1;
                }
                '(' => {
                    depth += 1;
                    current.push(c);
                }
                ')' => {
                    current.push(c);
                    depth -= 1;
                }
                ',' if depth == 1 => {
                    if current.contains(&format!("{}(", wrapper)) && !current.ends_with(')') {
                        current.push(')');
                    }
                    result.push_str(&current);
                    result.push(',');
                    current = String::new();
                }
                _ => current.push(c),
            }
        }
    }

    result.push_str(&current);
    result
}

// ------------------------------------------------------------- Unit Tests

#[cfg(test)]
mod tests {
    use super::*;

    // ----------------------------------------- escape_gleam_string tests

    #[test]
    fn test_escape_gleam_string() {
        assert_eq!(escape_gleam_string("hello"), "hello");
        assert_eq!(escape_gleam_string("hello\nworld"), "hello\\nworld");
        assert_eq!(escape_gleam_string("say \"hi\""), "say \\\"hi\\\"");
    }

    // ----------------------------------------- to_field_name tests

    #[test]
    fn test_to_field_name() {
        assert_eq!(to_field_name("user-name"), "user_name");
        assert_eq!(to_field_name("userName"), "user_name");
        assert_eq!(to_field_name("forms:input"), "forms_input");
    }

    // ----------------------------------------- component_module_alias tests

    #[test]
    fn test_component_module_alias() {
        assert_eq!(component_module_alias("button"), "components_button");
        assert_eq!(
            component_module_alias("forms:input"),
            "components_forms_input"
        );
    }

    // ----------------------------------------- is_void_element tests

    #[test]
    fn test_is_void_element() {
        assert!(is_void_element("img"));
        assert!(is_void_element("br"));
        assert!(is_void_element("input"));
        assert!(!is_void_element("div"));
        assert!(!is_void_element("span"));
    }

    // ----------------------------------------- default_for_type tests

    #[test]
    fn test_default_for_type() {
        assert_eq!(default_for_type("Bool"), "False");
        assert_eq!(default_for_type("String"), "\"\"");
        assert_eq!(default_for_type("Option(String)"), "None");
        assert_eq!(default_for_type("List(Int)"), "[]");
    }

    // ----------------------------------------- generate_node_code tests

    #[test]
    fn test_slot_with_fallback_generates_valid_code() {
        let node = Node::Slot {
            name: None,
            fallback: vec![Node::Text("default content".to_string())],
        };
        let component_data = ComponentDataMap::new();
        let component_slots = ComponentSlotMap::new();

        let code = generate_node_code(&node, 1, &component_data, &component_slots);

        // Should not contain literal \n (escaped newline in output)
        assert!(
            !code.contains(r"\n"),
            "Generated code contains literal \\n: {}",
            code
        );
        // Should contain actual newlines
        assert!(
            code.contains('\n'),
            "Generated code should contain actual newlines"
        );
        // Should have both append_if calls
        assert!(
            code.contains(r#"append_if(slot == """#),
            "Missing first append_if: {}",
            code
        );
        assert!(
            code.contains(r#"append_if(slot != """#),
            "Missing second append_if: {}",
            code
        );
    }

    #[test]
    fn test_named_slot_with_fallback_generates_valid_code() {
        let node = Node::Slot {
            name: Some("header".to_string()),
            fallback: vec![Node::Text("default header".to_string())],
        };
        let component_data = ComponentDataMap::new();
        let component_slots = ComponentSlotMap::new();

        let code = generate_node_code(&node, 1, &component_data, &component_slots);

        // Should not contain literal \n
        assert!(
            !code.contains(r"\n"),
            "Generated code contains literal \\n: {}",
            code
        );
        // Should reference the named slot variable
        assert!(
            code.contains("slot_header"),
            "Should reference slot_header: {}",
            code
        );
    }
}
