use crate::config::RouteGroup;
use crate::parser::Route;
use std::collections::{HashMap, HashSet};
use std::fs;

const COMPILED_DIR: &str = "src/compiled/routes";
const GREEN: &str = "\x1b[0;32m";
const NC: &str = "\x1b[0m";

/// Compile a route group and return the number of routes
pub fn compile_group(
    group: &RouteGroup,
    all_routes: &[Route],
    all_groups: &[RouteGroup],
    verbose: bool,
) -> usize {
    // Filter routes that belong to this group (longest prefix match)
    let group_routes: Vec<&Route> = all_routes
        .iter()
        .filter(|r| best_matching_group(&r.path, all_groups) == group.name)
        .collect();

    if group_routes.is_empty() {
        return 0;
    }

    let code = generate_routes_code(group, &group_routes);

    // Ensure output directory exists
    fs::create_dir_all(COMPILED_DIR).ok();

    let output_path = format!("{}/{}.gleam", COMPILED_DIR, group.name);
    if let Err(e) = fs::write(&output_path, &code) {
        eprintln!("Error writing {}: {}", output_path, e);
        return 0;
    }

    if verbose {
        eprintln!(
            "  {}.gleam -> {}{} routes{}",
            group.name,
            GREEN,
            group_routes.len(),
            NC
        );
    }

    group_routes.len()
}

/// Find the best matching group for a route path (longest prefix)
fn best_matching_group(path: &str, groups: &[RouteGroup]) -> String {
    let mut best_match = "web".to_string();
    let mut best_len = 0;

    for group in groups {
        if group.prefix.is_empty() {
            if best_len == 0 {
                best_match = group.name.clone();
            }
        } else if path.starts_with(&group.prefix) && group.prefix.len() > best_len {
            best_match = group.name.clone();
            best_len = group.prefix.len();
        }
    }

    best_match
}

/// Generate the Gleam code for a route group
fn generate_routes_code(group: &RouteGroup, routes: &[&Route]) -> String {
    let mut code = String::new();

    // Header comment
    code.push_str("//// This file was generated by Glimr\n");
    code.push_str("//// https://github.com/glimr-org/glimr?tab=readme-ov-file#routes\n");
    code.push_str("////\n");
    code.push_str("//// DO NOT EDIT THIS FILE. If you would like to use plain pattern\n");
    code.push_str("//// matching over this compiled route approach, take a look at\n");
    code.push_str("//// the docs link below detailing how to do so.\n");
    code.push_str("////\n");
    code.push_str(
        "//// See: https://github.com/glimr-org/glimr?tab=readme-ov-file#direct-pattern-matching\n",
    );
    code.push_str("////\n\n");

    // Collect imports
    let imports = collect_imports(routes, group);
    code.push_str(&imports);
    code.push('\n');

    // Check if any handler uses req or ctx, or if middleware/validators need them
    let has_middleware = routes
        .iter()
        .any(|r| !r.middleware.is_empty() || !r.group_middleware.is_empty());
    let has_validator = routes.iter().any(|r| r.validator.is_some());
    let uses_req = has_middleware
        || has_validator
        || routes
            .iter()
            .any(|r| r.params.iter().any(|p| p.name == "req"));
    let uses_ctx = has_middleware
        || has_validator
        || routes
            .iter()
            .any(|r| r.params.iter().any(|p| p.name == "ctx"));

    // Generate function signature
    let req_param = if uses_req { "req" } else { "_req" };
    let ctx_param = if uses_ctx { "ctx" } else { "_ctx" };

    code.push_str(&format!(
        "pub fn routes(path, method, {}, {}) {{\n",
        req_param, ctx_param
    ));

    // Generate route matching
    code.push_str("  case path {\n");

    // Group routes by path for method dispatch
    let routes_by_path = group_routes_by_path(routes, &group.prefix);

    // Sort paths: static before parameterized
    let mut paths: Vec<_> = routes_by_path.keys().collect();
    paths.sort_by(|a, b| {
        let a_has_param = a.contains(':');
        let b_has_param = b.contains(':');
        match (a_has_param, b_has_param) {
            (false, true) => std::cmp::Ordering::Less,
            (true, false) => std::cmp::Ordering::Greater,
            _ => a.cmp(b),
        }
    });

    for path in paths {
        let path_routes = &routes_by_path[path];
        let pattern = path_to_pattern(path);

        code.push_str(&format!("    {} ->\n", pattern));
        code.push_str("      case method {\n");

        for route in path_routes {
            let method = to_pascal_case(&route.method);
            code.push_str(&format!(
                "        {} -> {}",
                method,
                generate_handler_call(route)
            ));
        }

        // Method not allowed
        let methods: Vec<_> = path_routes
            .iter()
            .map(|r| to_pascal_case(&r.method))
            .collect();
        code.push_str(&format!(
            "        _ -> wisp.method_not_allowed([{}])\n",
            methods.join(", ")
        ));
        code.push_str("      }\n\n");
    }

    // Default case - not found
    code.push_str("    _ -> wisp.not_found()\n");
    code.push_str("  }\n");
    code.push_str("}\n");

    code
}

/// Collect all necessary imports
fn collect_imports(routes: &[&Route], _group: &RouteGroup) -> String {
    let mut controller_imports = Vec::new();
    let mut other_imports = Vec::new();
    let mut methods = HashSet::new();
    let mut has_middleware = false;
    let mut seen_controllers = HashSet::new();

    for route in routes {
        // Controller import
        let controller_import = controller_to_import(&route.controller_path);
        if !seen_controllers.contains(&controller_import) {
            seen_controllers.insert(controller_import.clone());
            controller_imports.push(controller_import);
        }

        // HTTP method (convert to PascalCase)
        methods.insert(to_pascal_case(&route.method));

        // Middleware imports
        for mw in &route.group_middleware {
            let imp = format!("import app/http/middleware/{}", mw);
            if !other_imports.contains(&imp) {
                other_imports.push(imp);
            }
            has_middleware = true;
        }
        for mw in &route.middleware {
            let imp = format!("import app/http/middleware/{}", mw);
            if !other_imports.contains(&imp) {
                other_imports.push(imp);
            }
            has_middleware = true;
        }

        // Validator import
        if let Some(ref v) = route.validator {
            let imp = format!("import app/http/validators/{}", v);
            if !other_imports.contains(&imp) {
                other_imports.push(imp);
            }
        }
    }

    if has_middleware {
        other_imports.push("import glimr/http/middleware".to_string());
    }

    // Build imports string - controller imports first, then http, then others
    controller_imports.sort();
    other_imports.sort();

    let mut result = String::new();

    for imp in controller_imports {
        result.push_str(&imp);
        result.push('\n');
    }

    // Add HTTP methods import
    if !methods.is_empty() {
        let mut method_list: Vec<_> = methods.into_iter().collect();
        method_list.sort();
        result.push_str(&format!(
            "import gleam/http.{{{}}}\n",
            method_list.join(", ")
        ));
    }

    for imp in other_imports {
        result.push_str(&imp);
        result.push('\n');
    }

    result.push_str("import wisp\n");

    result
}

/// Convert controller path to import statement
fn controller_to_import(path: &str) -> String {
    // src/app/http/controllers/home_controller.gleam -> app/http/controllers/home_controller
    let module_path = path.trim_start_matches("src/").trim_end_matches(".gleam");

    // Check if we need an alias (for nested controllers)
    let parts: Vec<&str> = module_path.split('/').collect();
    let file_name = parts.last().unwrap_or(&"");

    // Default import name is last segment
    let default_name = file_name.to_string();

    // If nested under controllers/, create alias
    if module_path.contains("controllers/") {
        let after_controllers = module_path
            .split("controllers/")
            .nth(1)
            .unwrap_or(file_name);
        let alias = after_controllers.replace('/', "_");

        if alias != default_name {
            return format!("import {} as {}", module_path, alias);
        }
    }

    format!("import {}", module_path)
}

/// Group routes by their path (without group prefix)
fn group_routes_by_path<'a>(routes: &[&'a Route], prefix: &str) -> HashMap<String, Vec<&'a Route>> {
    let mut map: HashMap<String, Vec<&Route>> = HashMap::new();

    for route in routes {
        let path = if !prefix.is_empty() && route.path.starts_with(prefix) {
            route.path[prefix.len()..].to_string()
        } else {
            route.path.clone()
        };

        let path = if path.is_empty() {
            "/".to_string()
        } else {
            path
        };

        map.entry(path).or_default().push(route);
    }

    map
}

/// Convert path to Gleam pattern match
fn path_to_pattern(path: &str) -> String {
    if path == "/" {
        return "[]".to_string();
    }

    let segments: Vec<String> = path
        .trim_start_matches('/')
        .split('/')
        .map(|s| {
            if s.starts_with(':') {
                // Parameter - use variable name
                s[1..].to_string()
            } else {
                // Static segment - quote it
                format!("\"{}\"", s)
            }
        })
        .collect();

    format!("[{}]", segments.join(", "))
}

/// Convert method to PascalCase (GET -> Get)
fn to_pascal_case(method: &str) -> String {
    let lower = method.to_lowercase();
    let mut chars: Vec<char> = lower.chars().collect();
    if !chars.is_empty() {
        chars[0] = chars[0].to_uppercase().next().unwrap();
    }
    chars.into_iter().collect()
}

/// Generate handler call with middleware/validator wrapping
fn generate_handler_call(route: &Route) -> String {
    // Get controller alias
    let controller_alias = get_controller_alias(&route.controller_path);

    // Collect all middleware
    let mut all_middleware: Vec<String> = route.group_middleware.clone();
    all_middleware.extend(route.middleware.clone());

    // Handle redirect
    if let Some(ref redirect_path) = route.redirect {
        if route.redirect_permanent {
            return format!("wisp.permanent_redirect(\"{}\")\n", redirect_path);
        } else {
            return format!("wisp.redirect(\"{}\")\n", redirect_path);
        }
    }

    // Build handler call args
    let args = build_handler_args(route);

    // Simple case - no middleware, no validator
    if all_middleware.is_empty() && route.validator.is_none() {
        return format!("{}.{}({})\n", controller_alias, route.handler, args);
    }

    // Complex case - need block
    let mut code = String::from("{\n");

    // If we have middleware
    if !all_middleware.is_empty() {
        let mw_list: Vec<String> = all_middleware
            .iter()
            .map(|m| format!("{}.run", m))
            .collect();
        // Check if handler or validator needs req/ctx after middleware
        let handler_uses_req = route.params.iter().any(|p| p.name == "req");
        let handler_uses_ctx = route.params.iter().any(|p| p.name == "ctx");
        let has_validator = route.validator.is_some();
        let req_bind = if handler_uses_req || has_validator {
            "req"
        } else {
            "_req"
        };
        let ctx_bind = if handler_uses_ctx || has_validator {
            "ctx"
        } else {
            "_ctx"
        };
        code.push_str(&format!(
            "          use {}, {} <- middleware.apply([{}], req, ctx)\n",
            req_bind,
            ctx_bind,
            mw_list.join(", ")
        ));
    }

    // If we have validator
    if let Some(ref validator) = route.validator {
        code.push_str(&format!(
            "          use validated <- {}.validate(req, ctx)\n",
            validator
        ));
    }

    // Handler call
    code.push_str(&format!(
        "          {}.{}({})\n",
        controller_alias, route.handler, args
    ));
    code.push_str("        }\n");

    code
}

/// Get controller alias from path
fn get_controller_alias(path: &str) -> String {
    let module_path = path.trim_start_matches("src/").trim_end_matches(".gleam");

    if module_path.contains("controllers/") {
        module_path
            .split("controllers/")
            .nth(1)
            .unwrap_or("")
            .replace('/', "_")
    } else {
        module_path.split('/').last().unwrap_or("").to_string()
    }
}

/// Build handler argument list
fn build_handler_args(route: &Route) -> String {
    let mut args = Vec::new();

    for param in &route.params {
        // Determine what value to pass
        let value = if param.name == "req" {
            "req".to_string()
        } else if param.name == "ctx" {
            "ctx".to_string()
        } else if param.name == "validated" || param.name == "data" {
            "validated".to_string()
        } else if param.param_type.contains("Data") {
            "validated".to_string()
        } else {
            // Path parameter - use the variable name
            param.name.clone()
        };

        args.push(value);
    }

    args.join(", ")
}

#[cfg(test)]
mod tests {
    use super::*;
    use crate::parser::FunctionParam;

    // Helper to create a route
    fn make_route(
        method: &str,
        path: &str,
        handler: &str,
        controller_path: &str,
        params: Vec<(&str, &str)>,
    ) -> Route {
        Route {
            method: method.to_string(),
            path: path.to_string(),
            handler: handler.to_string(),
            controller_path: controller_path.to_string(),
            middleware: vec![],
            validator: None,
            redirect: None,
            redirect_permanent: false,
            params: params
                .into_iter()
                .map(|(name, typ)| FunctionParam {
                    name: name.to_string(),
                    param_type: typ.to_string(),
                })
                .collect(),
            group_middleware: vec![],
            return_type: "Response".to_string(),
            has_wisp_response_import: true,
        }
    }

    fn make_group(name: &str, prefix: &str) -> RouteGroup {
        RouteGroup {
            name: name.to_string(),
            prefix: prefix.to_string(),
        }
    }

    // ============================================================
    // to_pascal_case tests
    // ============================================================

    #[test]
    fn test_to_pascal_case_get() {
        assert_eq!(to_pascal_case("GET"), "Get");
    }

    #[test]
    fn test_to_pascal_case_post() {
        assert_eq!(to_pascal_case("POST"), "Post");
    }

    #[test]
    fn test_to_pascal_case_delete() {
        assert_eq!(to_pascal_case("DELETE"), "Delete");
    }

    #[test]
    fn test_to_pascal_case_already_pascal() {
        assert_eq!(to_pascal_case("Get"), "Get");
    }

    // ============================================================
    // path_to_pattern tests
    // ============================================================

    #[test]
    fn test_path_to_pattern_root() {
        assert_eq!(path_to_pattern("/"), "[]");
    }

    #[test]
    fn test_path_to_pattern_simple() {
        assert_eq!(path_to_pattern("/users"), "[\"users\"]");
    }

    #[test]
    fn test_path_to_pattern_nested() {
        assert_eq!(
            path_to_pattern("/users/profile"),
            "[\"users\", \"profile\"]"
        );
    }

    #[test]
    fn test_path_to_pattern_with_param() {
        assert_eq!(path_to_pattern("/users/:id"), "[\"users\", id]");
    }

    #[test]
    fn test_path_to_pattern_multiple_params() {
        assert_eq!(
            path_to_pattern("/users/:user_id/posts/:post_id"),
            "[\"users\", user_id, \"posts\", post_id]"
        );
    }

    // ============================================================
    // controller_to_import tests
    // ============================================================

    #[test]
    fn test_controller_to_import_simple() {
        assert_eq!(
            controller_to_import("src/app/http/controllers/home_controller.gleam"),
            "import app/http/controllers/home_controller"
        );
    }

    #[test]
    fn test_controller_to_import_nested() {
        assert_eq!(
            controller_to_import("src/app/http/controllers/api/users_controller.gleam"),
            "import app/http/controllers/api/users_controller as api_users_controller"
        );
    }

    #[test]
    fn test_controller_to_import_deeply_nested() {
        assert_eq!(
            controller_to_import("src/app/http/controllers/api/v1/admin_controller.gleam"),
            "import app/http/controllers/api/v1/admin_controller as api_v1_admin_controller"
        );
    }

    // ============================================================
    // get_controller_alias tests
    // ============================================================

    #[test]
    fn test_get_controller_alias_simple() {
        assert_eq!(
            get_controller_alias("src/app/http/controllers/home_controller.gleam"),
            "home_controller"
        );
    }

    #[test]
    fn test_get_controller_alias_nested() {
        assert_eq!(
            get_controller_alias("src/app/http/controllers/api/users_controller.gleam"),
            "api_users_controller"
        );
    }

    // ============================================================
    // build_handler_args tests
    // ============================================================

    #[test]
    fn test_build_handler_args_empty() {
        let route = make_route(
            "GET",
            "/",
            "show",
            "src/app/http/controllers/home.gleam",
            vec![],
        );
        assert_eq!(build_handler_args(&route), "");
    }

    #[test]
    fn test_build_handler_args_req_only() {
        let route = make_route(
            "GET",
            "/",
            "show",
            "src/app/http/controllers/home.gleam",
            vec![("req", "Request")],
        );
        assert_eq!(build_handler_args(&route), "req");
    }

    #[test]
    fn test_build_handler_args_req_and_ctx() {
        let route = make_route(
            "GET",
            "/",
            "show",
            "src/app/http/controllers/home.gleam",
            vec![("req", "Request"), ("ctx", "Context")],
        );
        assert_eq!(build_handler_args(&route), "req, ctx");
    }

    #[test]
    fn test_build_handler_args_path_param() {
        let route = make_route(
            "GET",
            "/users/:id",
            "show",
            "src/app/http/controllers/users.gleam",
            vec![("id", "String")],
        );
        assert_eq!(build_handler_args(&route), "id");
    }

    #[test]
    fn test_build_handler_args_validated() {
        let route = make_route(
            "POST",
            "/users",
            "create",
            "src/app/http/controllers/users.gleam",
            vec![("validated", "user_validator.Data")],
        );
        assert_eq!(build_handler_args(&route), "validated");
    }

    #[test]
    fn test_build_handler_args_data_type() {
        let route = make_route(
            "POST",
            "/users",
            "create",
            "src/app/http/controllers/users.gleam",
            vec![("user_data", "user_validator.Data")],
        );
        assert_eq!(build_handler_args(&route), "validated");
    }

    // ============================================================
    // best_matching_group tests
    // ============================================================

    #[test]
    fn test_best_matching_group_default() {
        let groups = vec![make_group("web", "")];
        assert_eq!(best_matching_group("/users", &groups), "web");
    }

    #[test]
    fn test_best_matching_group_api_prefix() {
        let groups = vec![make_group("web", ""), make_group("api", "/api")];
        assert_eq!(best_matching_group("/api/users", &groups), "api");
        assert_eq!(best_matching_group("/users", &groups), "web");
    }

    #[test]
    fn test_best_matching_group_longest_prefix() {
        let groups = vec![
            make_group("web", ""),
            make_group("api", "/api"),
            make_group("api_v2", "/api/v2"),
        ];
        assert_eq!(best_matching_group("/api/v2/users", &groups), "api_v2");
        assert_eq!(best_matching_group("/api/v1/users", &groups), "api");
        assert_eq!(best_matching_group("/users", &groups), "web");
    }

    // ============================================================
    // generate_handler_call tests
    // ============================================================

    #[test]
    fn test_generate_handler_call_simple() {
        let route = make_route(
            "GET",
            "/",
            "show",
            "src/app/http/controllers/home_controller.gleam",
            vec![],
        );
        let result = generate_handler_call(&route);
        assert_eq!(result, "home_controller.show()\n");
    }

    #[test]
    fn test_generate_handler_call_with_params() {
        let route = make_route(
            "GET",
            "/users/:id",
            "show",
            "src/app/http/controllers/users_controller.gleam",
            vec![("id", "String")],
        );
        let result = generate_handler_call(&route);
        assert_eq!(result, "users_controller.show(id)\n");
    }

    #[test]
    fn test_generate_handler_call_redirect() {
        let mut route = make_route(
            "GET",
            "/old",
            "show",
            "src/app/http/controllers/home.gleam",
            vec![],
        );
        route.redirect = Some("/new".to_string());
        let result = generate_handler_call(&route);
        assert_eq!(result, "wisp.redirect(\"/new\")\n");
    }

    #[test]
    fn test_generate_handler_call_permanent_redirect() {
        let mut route = make_route(
            "GET",
            "/old",
            "show",
            "src/app/http/controllers/home.gleam",
            vec![],
        );
        route.redirect = Some("/new".to_string());
        route.redirect_permanent = true;
        let result = generate_handler_call(&route);
        assert_eq!(result, "wisp.permanent_redirect(\"/new\")\n");
    }

    #[test]
    fn test_generate_handler_call_with_middleware() {
        let mut route = make_route(
            "GET",
            "/",
            "show",
            "src/app/http/controllers/home_controller.gleam",
            vec![],
        );
        route.middleware = vec!["auth".to_string()];
        let result = generate_handler_call(&route);
        assert!(result.contains("middleware.apply([auth.run], req, ctx)"));
        assert!(result.contains("home_controller.show()"));
    }

    #[test]
    fn test_generate_handler_call_with_validator() {
        let mut route = make_route(
            "POST",
            "/users",
            "create",
            "src/app/http/controllers/users_controller.gleam",
            vec![("data", "user_validator.Data")],
        );
        route.validator = Some("user_validator".to_string());
        let result = generate_handler_call(&route);
        assert!(result.contains("user_validator.validate(req, ctx)"));
        assert!(result.contains("users_controller.create(validated)"));
    }
}
