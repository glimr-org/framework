import app/http/context/ctx.{type Context}
import glimr/forms/validator.{type Rule, type Validated}
import wisp.{type Request, type Response}

// docs: https://github.com/glimr-org/glimr?tab=readme-ov-file#form-validation

/// Define the shape of the data returned after validation
///
pub type Data {
  // Data(name: String)
  Data(todo)
}

/// Define your form's validation rules
///
fn rules() -> List(Rule(Context)) {
  [
    // validator.for("name", [validator.Required]),
    todo
  ]
}

/// Set the form data returned after validation. This is also 
/// where you can transform validated input data before it
/// reaches your controller.
///
fn data(data: Validated) -> Data {
  // Data(name: data.get("name"))
  Data(todo)
}

/// Run your validation rules. This is your entry point, you 
/// dont't usually have to adjust anything in this function, but 
/// you can if you want to add any custom logic before/after 
/// validation.
///
pub fn validate(req: Request, ctx: Context, next: fn(Data) -> Response) {
  use validated <- validator.run(
    req,
    ctx,
    ctx.response_format,
    ctx.session,
    rules,
    data,
  )

  next(validated)
}
